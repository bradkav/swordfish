<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>swordfish.Utils API documentation</title>
    <meta name="description" content="Overview and motivation
=======================

The purpose of swordfish is to enable fast and info..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
  <script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#swordfish.Utils.EquivalentCounts">EquivalentCounts</a></span>
        
          
  <ul>
    <li class="mono"><a href="#swordfish.Utils.EquivalentCounts.__init__">__init__</a></li>
    <li class="mono"><a href="#swordfish.Utils.EquivalentCounts.discoveryreach">discoveryreach</a></li>
    <li class="mono"><a href="#swordfish.Utils.EquivalentCounts.equivalentcounts">equivalentcounts</a></li>
    <li class="mono"><a href="#swordfish.Utils.EquivalentCounts.totalcounts">totalcounts</a></li>
    <li class="mono"><a href="#swordfish.Utils.EquivalentCounts.upperlimit">upperlimit</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#swordfish.Utils.EuclideanizedSignal">EuclideanizedSignal</a></span>
        
          
  <ul>
    <li class="mono"><a href="#swordfish.Utils.EuclideanizedSignal.__init__">__init__</a></li>
    <li class="mono"><a href="#swordfish.Utils.EuclideanizedSignal.x">x</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#swordfish.Utils.Funkfish">Funkfish</a></span>
        
          
  <ul>
    <li class="mono"><a href="#swordfish.Utils.Funkfish.__init__">__init__</a></li>
    <li class="mono"><a href="#swordfish.Utils.Funkfish.EquivalentCounts">EquivalentCounts</a></li>
    <li class="mono"><a href="#swordfish.Utils.Funkfish.LinModel">LinModel</a></li>
    <li class="mono"><a href="#swordfish.Utils.Funkfish.TensorField">TensorField</a></li>
    <li class="mono"><a href="#swordfish.Utils.Funkfish.iminuit">iminuit</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#swordfish.Utils.LinModel">LinModel</a></span>
        
          
  <ul>
    <li class="mono"><a href="#swordfish.Utils.LinModel.__init__">__init__</a></li>
    <li class="mono"><a href="#swordfish.Utils.LinModel.effectivefishermatrix">effectivefishermatrix</a></li>
    <li class="mono"><a href="#swordfish.Utils.LinModel.effectiveinfoflux">effectiveinfoflux</a></li>
    <li class="mono"><a href="#swordfish.Utils.LinModel.fishermatrix">fishermatrix</a></li>
    <li class="mono"><a href="#swordfish.Utils.LinModel.infoflux">infoflux</a></li>
    <li class="mono"><a href="#swordfish.Utils.LinModel.lnL">lnL</a></li>
    <li class="mono"><a href="#swordfish.Utils.LinModel.mu">mu</a></li>
    <li class="mono"><a href="#swordfish.Utils.LinModel.profile_lnL">profile_lnL</a></li>
    <li class="mono"><a href="#swordfish.Utils.LinModel.variance">variance</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">swordfish.Utils</span> module</h1>
  <h1>Overview and motivation</h1>
<p>The purpose of swordfish is to enable fast and informative forecasting for a
broad class of statistical models relevant for praticle physics and astronomy,
without requiring expensive Monte Carlos.  The results are in most cases
accurate, with a few important limitations discussed below.</p>
<p>With swordfish one can calculate</p>
<ul>
<li>expected median detection thresholds</li>
<li>expected median upper limits</li>
<li>reconstruction contours</li>
</ul>
<p>However, swordfish allows also to calculate uncommon (but very useful)
quantities like the</p>
<ul>
<li>Fisher information matrix</li>
<li>Fisher information flux</li>
<li>Equivalent signal and background counts</li>
<li>Estimate for trials factor</li>
</ul>
<p>which can guide the optimization of search strategies of experimental design.</p>
<p>The model implemented in swordfish is a Poisson Point Process with constraints
additive components and general background covariance matrix.  This model is
encompasses counting experiments in the zero background regime as well as
scenarios that are completely systematics domainted.</p>
<p>Swordfish can be used in the low-statistics regime as well as parts of the
parameter space that are very degenerate.  The main limitation is that it
cannot handle situations where both happens at the same time.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils" class="source">
    <div class="codehilite"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Overview and motivation</span>
<span class="sd">=======================</span>

<span class="sd">The purpose of swordfish is to enable fast and informative forecasting for a</span>
<span class="sd">broad class of statistical models relevant for praticle physics and astronomy,</span>
<span class="sd">without requiring expensive Monte Carlos.  The results are in most cases</span>
<span class="sd">accurate, with a few important limitations discussed below.</span>

<span class="sd">With swordfish one can calculate</span>

<span class="sd">- expected median detection thresholds</span>
<span class="sd">- expected median upper limits</span>
<span class="sd">- reconstruction contours</span>

<span class="sd">However, swordfish allows also to calculate uncommon (but very useful)</span>
<span class="sd">quantities like the</span>

<span class="sd">- Fisher information matrix</span>
<span class="sd">- Fisher information flux</span>
<span class="sd">- Equivalent signal and background counts</span>
<span class="sd">- Estimate for trials factor</span>

<span class="sd">which can guide the optimization of search strategies of experimental design.</span>

<span class="sd">The model implemented in swordfish is a Poisson Point Process with constraints</span>
<span class="sd">additive components and general background covariance matrix.  This model is</span>
<span class="sd">encompasses counting experiments in the zero background regime as well as</span>
<span class="sd">scenarios that are completely systematics domainted.</span>

<span class="sd">Swordfish can be used in the low-statistics regime as well as parts of the</span>
<span class="sd">parameter space that are very degenerate.  The main limitation is that it</span>
<span class="sd">cannot handle situations where both happens at the same time.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">gammaln</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">sqrtm</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fmin_l_bfgs_b</span><span class="p">,</span> <span class="n">brentq</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">swordfish.metricplot</span> <span class="kn">as</span> <span class="nn">mp</span>


<span class="k">class</span> <span class="nc">LinModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fisher analysis of general penalized Poisson likelihood models.</span>

<span class="sd">    A model is defined by the following quantities</span>

<span class="sd">    * $S_i^{(k)}$: </span>
<span class="sd">        Signal components, with $k=1, \dots, n$ components and $i=1,\dots, N$</span>
<span class="sd">        bins.</span>
<span class="sd">    - $B_i$: Background</span>
<span class="sd">    - $E_i$: Exposure</span>
<span class="sd">    - $K\_{ij}$: Background covariance matrix</span>
<span class="sd">    - $T_i$: Parameter constraints</span>
<span class="sd">    </span>
<span class="sd">    The corresponding likelihood function is given by</span>
<span class="sd">    $$</span>
<span class="sd">    \ln\mathcal{L}(\vec d|\vec\theta) = \max\_{\delta B_i} \left[</span>
<span class="sd">    \ln\mathcal{L}_p(\vec d| \vec\mu(\vec\theta, \delta \vec B)) +</span>
<span class="sd">    \ln\mathcal{L}_c(\vec\theta, \delta\vec B)</span>
<span class="sd">    \right]</span>
<span class="sd">    $$</span>
<span class="sd">    with a Poisson part</span>
<span class="sd">    $$</span>
<span class="sd">    \ln\mathcal{L}_p(\vec d|\vec \mu) = \sum\_{i=1}^N d_i \cdot\ln</span>
<span class="sd">    \mu_i - \mu_i -\ln\Gamma(d_i+1)</span>
<span class="sd">    $$</span>
<span class="sd">    and a constraint part</span>
<span class="sd">    $$</span>
<span class="sd">    \ln\mathcal{L}_c(\vec\theta, \delta \vec B) = </span>
<span class="sd">    \frac12 \sum_i \left(\frac{\theta_i}{T_i}\right)^2</span>
<span class="sd">    +\frac{1}{2}\sum\_{i,j} \delta B_i \left(K^{-1}\right)\_{ij} \delta B_j </span>
<span class="sd">    \;,</span>
<span class="sd">    $$</span>
<span class="sd">    where the expected differential number of counts is given by</span>
<span class="sd">    $$</span>
<span class="sd">    \mu_i(\vec\theta,\delta \vec B) = \left[\sum\_{k=1}^n \theta_k</span>
<span class="sd">    S_i^{(k)}+B_i+\delta B_i\right]\cdot E_i \;.</span>
<span class="sd">    $$</span>

<span class="sd">    Instances of this class define the model parameters, and provide methods to</span>
<span class="sd">    calcualte the associated Fisher information matrix and the information</span>
<span class="sd">    flux.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;direct&#39;</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `S` [matrix-like, shape=(n_comp, n_bins)]:</span>
<span class="sd">            Flux of signal components.</span>
<span class="sd">        * `B` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Background flux.</span>
<span class="sd">        * `E` [vector-like, shape=(n_bins), or `None`]:</span>
<span class="sd">            Exposure.  The value `None` implies that $E_i=1$.</span>
<span class="sd">        * `K` [matrix-like, shape=(n_bins, n_bins), or `None`]:</span>
<span class="sd">            Covariance matrix of background flux uncertainties.  Can handle</span>
<span class="sd">            anything that can be cast to a `LinearOperator` objects, in</span>
<span class="sd">            particular dense and sparse matrices.  The value `None` implies</span>
<span class="sd">            $\delta B_i = 0$.</span>
<span class="sd">        * `T` [vector-like or list-like, shape=(n_comp), or `None`]:</span>
<span class="sd">            Constraints on model parameters.  A list element `None` implies</span>
<span class="sd">            that no constraint is applied to the corresponding parameter.  If</span>
<span class="sd">            `T=None` no constraints are applied to any parameter.</span>
<span class="sd">        * `solver` [`&#39;direct&#39;` or `&#39;cg&#39;`]: </span>
<span class="sd">            Solver method used for matrix inversion, either conjugate gradient</span>
<span class="sd">            (cg) or direct matrix inversion.</span>
<span class="sd">        * `verbose` [boolean]:</span>
<span class="sd">            If set `True` various methods print additional information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;S is not matrix-like.&quot;</span>
        <span class="n">n_comp</span><span class="p">,</span> <span class="n">n_bins</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">=</span> <span class="n">S</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_bins</span><span class="p">,),</span> <span class="s2">&quot;B has incorrect shape.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span> <span class="o">=</span> <span class="n">B</span> 

        <span class="k">if</span> <span class="n">E</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">E</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_bins</span><span class="p">,),</span> <span class="s2">&quot;E has incorrect shape.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">=</span> <span class="n">E</span>

        <span class="k">if</span> <span class="n">K</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">((</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span> 
                    <span class="n">matvec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">assert</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span> <span class="s2">&quot;K has incorrect shape.&quot;</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="k">if</span> <span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_systematics</span> <span class="o">=</span> <span class="n">K</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_constraints</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">n_comp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="n">T</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">=</span> <span class="n">n_bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span> <span class="o">=</span> <span class="n">n_comp</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_auto_scale</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># Initialize internal cache</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_auto_scale</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">exposure</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">exposure</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flux</span><span class="p">]</span>
                <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">constraints</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">==</span> <span class="n">ncomp</span>
        <span class="k">if</span> <span class="n">constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
                    <span class="n">constraints</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">constraints</span><span class="o">&lt;=</span><span class="mf">0.</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Constraints must be positive or None.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">constraints</span>

    <span class="k">def</span> <span class="nf">_summedNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">noise_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span><span class="o">*</span><span class="mf">1.</span>  <span class="c1"># Make copy</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">))):</span>
                <span class="n">noise_tot</span> <span class="o">+=</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">noise_tot</span>

    <span class="k">def</span> <span class="nf">mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return expectation values for given model parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp), or `None`]:</span>
<span class="sd">            Model parameters.  The value `None` implies $\theta_i = 0$.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `mu` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Expectation value, $\mu_i(\vec \theta, \delta \vec B = 0)$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>

    <span class="k">def</span> <span class="nf">_solveD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates:</span>
<span class="sd">            N = noise + theta*flux</span>
<span class="sd">            D = diag(E)*Sigma*diag(E)+diag(N*E)</span>
<span class="sd">            x[i] = D^-1 flux[i]*E</span>

<span class="sd">        Note: if Sigma = None: x[i] = flux[i]/noise</span>

<span class="sd">        Returns:</span>
<span class="sd">            x, noise, exposure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="n">spexp</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">exposure</span><span class="p">))</span>
        <span class="n">D</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">noise</span><span class="o">*</span><span class="n">exposure</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">spexp</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_systematics</span><span class="o">*</span><span class="n">spexp</span>
                <span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">noise</span><span class="o">*</span><span class="n">exposure</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">==</span> <span class="s2">&quot;direct&quot;</span><span class="p">:</span>
            <span class="n">dense</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
            <span class="n">invD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dense</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invD</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">exposure</span><span class="p">)</span><span class="o">*</span><span class="n">exposure</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">==</span> <span class="s2">&quot;cg&quot;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
                    <span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">noise</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">/</span><span class="n">exposure</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cg</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">exposure</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">exposure</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Solver unknown.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">exposure</span>

    <span class="k">def</span> <span class="nf">fishermatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return Fisher information matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters.  The value `None` is equivalent to</span>
<span class="sd">            $\vec\theta=0$.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `I` [matrix-like, shape=(n_comp, n_comp)]:</span>
<span class="sd">            Fisher information matrix, $\mathcal{I}\_{ij}$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solveD</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">I</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">infoflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return Fisher information flux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters.  The value `None` is equivalent to</span>
<span class="sd">            $\vec\theta=0$.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `F` [3-D array, shape=(n_comp, n_comp, n_bins)]:</span>
<span class="sd">            Fisher information flux.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solveD</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">noise</span><span class="o">/</span><span class="p">(</span><span class="n">exposure</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span>
                <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="n">F</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">F</span>

    <span class="k">def</span> <span class="nf">effectivefishermatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexlist</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return effective Fisher information matrix for subset of components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `indexlist` [integer, or list of integers]:</span>
<span class="sd">            Components of interest.</span>
<span class="sd">        * `**kwargs`:</span>
<span class="sd">            Passed on to call of `fishermatrix`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `Ieff` [float, or matrix-like, shape=(len(indexlist),</span>
<span class="sd">            len(indexlist))]:</span>
<span class="sd">            Effective Fisher information matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexlist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
            <span class="n">indexlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexlist</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">),</span> <span class="n">indexlist</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexlist</span><span class="p">)</span>

        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fishermatrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indexlist</span><span class="p">,:][:,</span><span class="n">indexlist</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">,:][:,</span><span class="n">indexlist</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">,:][:,</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">invC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

        <span class="n">Ieff</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invC</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Ieff</span>

    <span class="k">def</span> <span class="nf">variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return variance of $\theta_i$.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]: </span>
<span class="sd">            Index of component of interest</span>
<span class="sd">        * `**kwargs`:</span>
<span class="sd">            Passed on to call of `fishermatrix`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `var` [float]:</span>
<span class="sd">            Variance of parameter $\theta_i$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fishermatrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">invI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">invI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">effectiveinfoflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return effective Fisher Information Flux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `**kwargs`:</span>
<span class="sd">            Passed on to call of `fishermatrix` and `infoflux`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `Feff` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Effective information flux.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infoflux</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fishermatrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">eff_F</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
        <span class="n">invB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">eff_F</span> <span class="o">=</span> <span class="n">eff_F</span> <span class="o">-</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">eff_F</span> <span class="o">=</span> <span class="n">eff_F</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">F</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">eff_F</span> <span class="o">=</span> <span class="n">eff_F</span> <span class="o">+</span> <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">F</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">eff_F</span>

    <span class="c1"># Likelihood with systematics</span>
    <span class="k">def</span> <span class="nf">lnL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">deltaB</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">derivative</span> <span class="o">=</span>
            <span class="bp">False</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return log-likelihood function, assuming Asimov data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta0` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters used for calculation of Asimov data.  Note that</span>
<span class="sd">            Asimov data is generated assuming $\delta\vec B =0$.</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters.</span>
<span class="sd">        * `deltaB`: [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Background variations of model.  A value of `None` corresponds to</span>
<span class="sd">            $\delta\vec B = 0$.</span>
<span class="sd">        * `epsilon` [float]:</span>
<span class="sd">            Fraction of diagonal noise that is added to K to stabilize matrix</span>
<span class="sd">            inversion.  Must be small enough to not affect results.</span>
<span class="sd">        * `derivative` [boolean]:</span>
<span class="sd">            If set to `True`, function also resturns partial derivatives w.r.t.</span>
<span class="sd">            model parameters.</span>
<span class="sd">        * `mu_overwrite` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            This parameter is internally used to handle non-linear models.  It</span>
<span class="sd">            overwrites the model predictions that are derived from `theta` and</span>
<span class="sd">            `deltaB`.  In that case, `theta` and `deltaB` only affect the</span>
<span class="sd">            constraint part of the likelihood.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `lnL` [float]:</span>
<span class="sd">            Log-likelihood, including Poisson and constraint part.</span>

<span class="sd">        OR if `derivative == True`</span>

<span class="sd">        * `lnL, dlnL_dtheta, dlnL_deltaB` </span>
<span class="sd">            [(float, vector-like with shape=(n_comp), vector-like with shape=(n_bins))]:</span>
<span class="sd">            Log-likelihood and its partial derivatives.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">deltaB</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="n">systnoise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span><span class="o">*</span><span class="n">epsilon</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="k">if</span> <span class="n">mu_overwrite</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">mu_overwrite</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dmu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">+=</span> <span class="n">dmu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_at_bound</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">mu</span><span class="o">&lt;</span><span class="n">mu0</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mu</span><span class="o">&lt;</span><span class="n">mu0</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">mu0</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
        <span class="n">lnL</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">-</span><span class="n">mu</span><span class="o">-</span><span class="mi">0</span><span class="o">*</span><span class="n">gammaln</span><span class="p">(</span><span class="n">mu0</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1">#print mu0.sum(), mu.sum()</span>
        <span class="n">lnL</span> <span class="o">-=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">theta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
            <span class="n">dense</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_systematics</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
            <span class="c1">#invS = np.linalg.linalg.inv(dense+np.eye(self._nbins)*epsilon)</span>
            <span class="n">invS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dense</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">systnoise</span><span class="p">))</span>
            <span class="n">lnL</span> <span class="o">-=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">invS</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmu</span><span class="p">)</span><span class="o">*</span><span class="n">dmu</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">derivative</span><span class="p">:</span>
            <span class="n">dlnL_dtheta</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu0</span><span class="o">/</span><span class="n">mu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">dlnL_dtheta</span> <span class="o">-=</span> <span class="n">theta</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
                <span class="n">dlnL_dmu</span> <span class="o">=</span> <span class="n">mu0</span><span class="o">/</span><span class="n">mu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">-</span> <span class="n">invS</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmu</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dlnL_dmu</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">lnL</span><span class="p">,</span> <span class="n">dlnL_dtheta</span><span class="p">,</span> <span class="n">dlnL_dmu</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lnL</span>

    <span class="k">def</span> <span class="nf">profile_lnL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">free_theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
            <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return profile log-likelihood.</span>

<span class="sd">        Note: Profiling is done using `scipy.optimize.fmin_l_bfgs_b`.  All</span>
<span class="sd">        $\delta \vec B$ are treated as free parameters, as well as those model</span>
<span class="sd">        parameters $\theta_i$ that are specified in `free_theta`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        * `theta0` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters used for calculation of Asimov data.  Note that</span>
<span class="sd">            Asimov data is generated assuming $\delta\vec B =0$.</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters.</span>
<span class="sd">        * `epsilon` [float]:</span>
<span class="sd">            Fraction of diagonal noise that is added to K to stabilize matrix</span>
<span class="sd">            inversion.  Must be small enough to not affect results.</span>
<span class="sd">        * `free_theta` [list-like, shape=(n_comp)]:</span>
<span class="sd">            If a list entry is set to `True`, the corresponding model parameter</span>
<span class="sd">            will be maximized.</span>
<span class="sd">        * `mu_overwrite` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            See `lnL`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `profile_lnL` [float]:</span>
<span class="sd">            Profile log-likelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">free_theta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">free_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">free_theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">Nfree_theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_theta</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">Nsyst</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">Nfree_theta</span> <span class="o">+</span> <span class="n">Nsyst</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">x0</span><span class="p">[:</span><span class="n">Nfree_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">free_theta</span><span class="p">]</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">global</span> <span class="n">fp</span>
            <span class="n">theta</span><span class="p">[</span><span class="n">free_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">Nfree_theta</span><span class="p">]</span>
            <span class="n">dmu</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">Nfree_theta</span><span class="p">:]</span>
            <span class="n">lnL</span><span class="p">,</span> <span class="n">grad_theta</span><span class="p">,</span> <span class="n">grad_dmu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnL</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">deltaB</span> <span class="o">=</span> <span class="n">dmu</span><span class="p">,</span>
                    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">derivative</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="n">mu_overwrite</span><span class="p">)</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="n">fp</span><span class="p">[:</span><span class="n">Nfree_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_theta</span><span class="p">[</span><span class="n">free_theta</span><span class="p">]</span>
            <span class="n">fp</span><span class="p">[</span><span class="n">Nfree_theta</span><span class="p">:]</span> <span class="o">=</span> <span class="n">grad_dmu</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">lnL</span>
        <span class="k">def</span> <span class="nf">fprime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">global</span> <span class="n">fp</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">fp</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnL</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="n">mu_overwrite</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fmin_l_bfgs_b</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">fprime</span><span class="p">,</span> <span class="n">approx_grad</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s2">&quot;Best-fit parameters:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_bound</span><span class="p">:</span>
            <span class="k">print</span> <span class="s2">&quot;WARNING: No maximum with non-negative flux found.&quot;</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">EuclideanizedSignal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># WARNING: This only cares about the covariance matrix and background, not</span>
    <span class="c1"># the individual S components</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;*Effective vector* calculation based on a `LinModel` instance.</span>

<span class="sd">        The distance method provides a simple way to calculate the</span>
<span class="sd">        expected statistical distance between two signals, accounting for</span>
<span class="sd">        background variations and statistical uncertainties.  In practice, it</span>
<span class="sd">        maps signal spectra on distance vectors such that the Eucledian</span>
<span class="sd">        distance between vectors corresponds to the statistical</span>
<span class="sd">        difference between signal spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A0</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_get_A</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return matrix `A`, such that x = A*S is the Eucledian distance vector.&quot;&quot;&quot;</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_noise</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">*</span><span class="mf">1.</span>  <span class="c1"># Noise without anything extra</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">noise</span> <span class="o">+=</span> <span class="n">S</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="n">spexp</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">exposure</span><span class="p">))</span>

        <span class="c1"># Definition: D = N*E + E*Sigma*E</span>
        <span class="n">D</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">noise</span><span class="o">*</span><span class="n">exposure</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">spexp</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_systematics</span><span class="o">*</span><span class="n">spexp</span>
                <span class="p">)</span>
        <span class="c1"># TODO: Add all components and their errors to D</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>  <span class="c1"># transform to dense matrix</span>
        <span class="n">invD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">A2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invD</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">exposure</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">A2</span><span class="p">)</span>
        <span class="n">Kdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_systematics</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_nbins</span><span class="p">)))</span>
        <span class="n">nA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise</span><span class="o">*</span><span class="n">exposure</span><span class="o">+</span><span class="n">Kdiag</span><span class="o">*</span><span class="n">exposure</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nA</span>

    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return model distance vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `S` [array-like, shape=(n_bins)]:</span>
<span class="sd">            Flux of signal component</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_A</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">EquivalentCounts</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;*Equivalent counts* analysis based on a `LinModel` instance.</span>

<span class="sd">    The equivalent counts method can be used to derive</span>
<span class="sd">    </span>
<span class="sd">    - expected upper limits</span>
<span class="sd">    - discovery reach</span>
<span class="sd">    - equivalent signal and background counts</span>
<span class="sd">    </span>
<span class="sd">    based on the Fisher information matrix of general penalized Poisson</span>
<span class="sd">    likelihood models.  The results are usually rather accurate, and work in</span>
<span class="sd">    the statistics limited, background limited and systematics limited regime.</span>
<span class="sd">    However, they require that the parameter of interest is (a) unconstrained</span>
<span class="sd">    and (b) corresponds to a component normalization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Paramters</span>
<span class="sd">        ---------</span>
<span class="sd">        * `model` [instance of `LinModel` class]:</span>
<span class="sd">            Input LinModel model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">totalcounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return total signal and background counts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `theta_i` [float]:</span>
<span class="sd">            Normalization of component i.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `s` [float]:</span>
<span class="sd">            Total signal counts.</span>
<span class="sd">        * `b` [float]:</span>
<span class="sd">            Total background counts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_exposure</span><span class="o">*</span><span class="n">theta_i</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_noise</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">equivalentcounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return equivalent signal and background counts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `theta_i` [float]:</span>
<span class="sd">            Normalization of component i.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `s` [float]:</span>
<span class="sd">            Equivalent signal counts.</span>
<span class="sd">        * `b` [float]:</span>
<span class="sd">            Equivalent background counts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">I0</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">)</span>
        <span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_i</span>
        <span class="n">I</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">thetas</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">I0</span> <span class="o">==</span> <span class="n">I</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">seff</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">I</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">I0</span><span class="p">)</span><span class="o">*</span><span class="n">theta_i</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">beff</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">I0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">I</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">I0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">theta_i</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">seff</span><span class="p">,</span> <span class="n">beff</span>

    <span class="k">def</span> <span class="nf">upperlimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">force_gaussian</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">brentq_kwargs</span>
            <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">}):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return expected upper limit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `alpha` [float]:</span>
<span class="sd">            Statistical significance.  For example, 0.05 means 95% confidence</span>
<span class="sd">            level.</span>
<span class="sd">        * `force_gaussian` [boolean]:</span>
<span class="sd">            Force calculation of Gaussian errors (faster, but only accurate in</span>
<span class="sd">            Gaussian regime).</span>
<span class="sd">        * `brentq_kwargs` [dict]:</span>
<span class="sd">            Keyword arguments passed to root-finding algorithm</span>
<span class="sd">            `scipy.optimize.brentq`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `thetaUL` [float]:</span>
<span class="sd">            Expected median upper limit on $\theta_i$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">I0</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">force_gaussian</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">)</span>
            <span class="n">thetaUL_est</span> <span class="o">=</span> <span class="n">Z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I0</span><span class="p">)</span>  <span class="c1"># Gaussian estimate</span>
            <span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaUL_est</span>
            <span class="n">I</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">thetas</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">I0</span><span class="o">-</span><span class="n">I</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.02</span><span class="o">*</span><span class="n">I</span><span class="p">:</span>  <span class="c1"># 1% accuracy of limits</span>
                <span class="k">return</span> <span class="n">thetaUL_est</span>

        <span class="c1"># Solve: s/np.sqrt(s+b) - Z = 0</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalentcounts</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># TODO: Check</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">Z</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">thetaUL_est</span><span class="o">*</span><span class="n">factor</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">thetaUL_est</span><span class="p">,</span> <span class="n">thetaUL_est</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span> <span class="o">**</span><span class="n">brentq_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">theta0</span>

    <span class="k">def</span> <span class="nf">discoveryreach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">force_gaussian</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
            <span class="n">brentq_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">}):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return expected discovery reach.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `alpha` [float]:</span>
<span class="sd">            Statistical significance.</span>
<span class="sd">        * `force_gaussian` [boolean]:</span>
<span class="sd">            Force calculation of Gaussian errors (faster, but only accurate in</span>
<span class="sd">            Gaussian regime).</span>
<span class="sd">        * `brentq_kwargs` [dict]:</span>
<span class="sd">            Keyword arguments passed to root-finding algorithm</span>
<span class="sd">            `scipy.optimize.brentq`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `thetaDT` [float]:</span>
<span class="sd">            Expected median discovery reach for $\theta_i$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">var0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">force_gaussian</span><span class="p">:</span>  <span class="c1"># Gaussian approximation</span>
            <span class="k">return</span> <span class="n">Z</span><span class="o">*</span><span class="n">var0</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">)</span>
        <span class="n">thetaDT_est</span> <span class="o">=</span> <span class="n">Z</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var0</span><span class="p">)</span>  <span class="c1"># Gaussian approx. as starting point</span>
        <span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaDT_est</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">thetas</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">var0</span> <span class="o">-</span> <span class="n">var</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.02</span><span class="o">*</span><span class="n">var</span><span class="p">:</span>  <span class="c1"># Still Gaussian enough</span>
            <span class="k">return</span> <span class="n">Z</span><span class="o">*</span><span class="n">var0</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="c1"># Solve: Z**2/2 - ((s+b)*np.log((s+b)/b)-s) = 0</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalentcounts</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># TODO: Check</span>
            <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">Z</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">thetaDT_est</span><span class="o">*</span><span class="n">factor</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">thetaDT_est</span><span class="p">,</span> <span class="n">thetaDT_est</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span> <span class="o">**</span><span class="n">brentq_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">theta0</span>

<span class="k">def</span> <span class="nf">_func_to_templates</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return finite differences for use in LinModel.&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="mf">0.01</span>
    <span class="n">fluxes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#fluxes.append(flux(*x))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">xU</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xL</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xU</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">xL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span><span class="n">flux</span><span class="p">(</span><span class="o">*</span><span class="n">xU</span><span class="p">)</span> <span class="o">-</span> <span class="n">flux</span><span class="p">(</span><span class="o">*</span><span class="n">xL</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fluxes</span>


<span class="k">class</span> <span class="nc">Funkfish</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;`LinModel`, `EquivalentCounts` and `iminuit`-factory, based on non-linear models.</span>

<span class="sd">    The underlying likelihood function is identical to the one of `LinModel`,</span>
<span class="sd">    with the only difference that model expectations are derived from</span>
<span class="sd">    $$</span>
<span class="sd">    \mu_i(\vec\theta, \delta \vec B) = \left[ f_i(\vec\theta) + \delta B_i\right]\cdot E_i</span>
<span class="sd">    $$</span>

<span class="sd">    `Funkfish` can generate `LinModel` and `EquivalentCounts` objects as local</span>
<span class="sd">    approximations to the non-linear model, as well as `iminuit` instances</span>
<span class="sd">    based on the non-linear model directly.  This facilitates (a) the fast</span>
<span class="sd">    analysis of non-linear models and (b) the comparison between results based</span>
<span class="sd">    on Fisher information and results from a full likelihood analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `f` [function]:</span>
<span class="sd">            Function of `n_comp` float arguments, returns `n_bins` flux</span>
<span class="sd">            expectation values, $\vec\mu(\vec\theta)$.</span>
<span class="sd">        * `theta0` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Default model parameters.</span>
<span class="sd">        * `E` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Exposure.  See `LinModel` documentation for details.</span>
<span class="sd">        * `K` [matrix-like]:</span>
<span class="sd">            Covariance matrix.  See `LinModel` documentation for details.</span>
<span class="sd">        * `T` [vector-like]:</span>
<span class="sd">            Model parameter constraints.  See `LinModel` documentation for</span>
<span class="sd">            details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Sigma</span> <span class="o">=</span> <span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="n">T</span>

    <span class="k">def</span> <span class="nf">_get_x0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get updated x0.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">x0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">x0</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_init_minuit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">x_fix</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">x_err</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">x_lim</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">errordef</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize minuit using no-nonsense interface.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">iminuit</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s2">&quot;This function requires that the module iminuit is installed.&quot;</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_err</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span>
        <span class="k">if</span> <span class="n">x_lim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_lim</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span>
        <span class="k">if</span> <span class="n">x_fix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_fix</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span>
        <span class="n">varnames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="k">def</span> <span class="nf">wf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">varnames</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x_lim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;limit_&quot;</span><span class="o">+</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_lim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;error_&quot;</span><span class="o">+</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x_fix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;fix_&quot;</span><span class="o">+</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">iminuit</span><span class="o">.</span><span class="n">Minuit</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span> <span class="n">forced_parameters</span> <span class="o">=</span> <span class="n">varnames</span><span class="p">,</span> <span class="n">errordef</span> <span class="o">=</span>
                <span class="n">errordef</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LinModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate `LinModel` instance.</span>

<span class="sd">        The generated `LinModel` instance is a local approximation to the</span>
<span class="sd">        non-linear model.  It is defined by</span>
<span class="sd">        $$</span>
<span class="sd">        B_i \equiv f_i(\vec\theta_0)</span>
<span class="sd">        $$</span>
<span class="sd">        and</span>
<span class="sd">        $$</span>
<span class="sd">        S_i \equiv \frac{\partial f_i}{\partial \theta_i}(\vec\theta_0)</span>
<span class="sd">        $$</span>
<span class="sd">        where $\vec\theta_0$ is the expansion parameter defined below.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta0` [dictionary, or vector-like with shape=(n_comp), or `None`]:</span>
<span class="sd">            If vector-like, it overwrites the default `theta0`.  A dictionary with keys</span>
<span class="sd">            $i$ and values $\theta_i$ updates the default.  If `None` the</span>
<span class="sd">            default is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `SF` [`LinModel` instance]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">_func_to_templates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">(</span><span class="o">*</span><span class="n">x0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LinModel</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Sigma</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EquivalentCounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate `EquivalentCounts` instance.</span>

<span class="sd">        Directly generates `EquivalentCounts` instance from `LinModel`</span>
<span class="sd">        instance.  See documentation of `get_LinModel` method .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EquivalentCounts</span><span class="p">(</span><span class="n">SF</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TensorField</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">logx</span> <span class="o">=</span>
            <span class="bp">False</span><span class="p">,</span> <span class="n">logy</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate `TensorField` instance.</span>

<span class="sd">        Samples Fisher information matrix on a 2-D grid, and generates an</span>
<span class="sd">        instance of `TensorField` that can be used to study parameter</span>
<span class="sd">        degeneracies, confidence contours, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `ix` [integer]:</span>
<span class="sd">            Index of first component of interest, mapped on x-axis.</span>
<span class="sd">        * `iy` [integer]:</span>
<span class="sd">            Index of second component of interest, mapped on y-axis.</span>
<span class="sd">        * `x_values` [vector-like, shape=(nx)]:</span>
<span class="sd">            Values of model parameter `ix` along x-axis.</span>
<span class="sd">        * `y_values` [vector-like, shape=(ny)]:</span>
<span class="sd">            Values of model parameter `iy` along y-axis.</span>
<span class="sd">        * `theta0` [dictionary, or vector-like with shape=(n_comp), or `None`]:</span>
<span class="sd">            If vector-like, it overwrites the default `theta0`.  A dictionary with keys</span>
<span class="sd">            $i$ and values $\theta_i$ updates the default.  If `None` the</span>
<span class="sd">            default is used.  Defines all parameters, except the parameters</span>
<span class="sd">            with indices `ix` and `iy`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `TF` [`TensorField` instance]:</span>
<span class="sd">            Based on an interpolated version of the Fisher information matrix</span>
<span class="sd">            that is sampled from the (nx, ny) grid defined by `x_values` and</span>
<span class="sd">            `y_values`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Update docstring</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_values</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_values</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y_values</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_values</span><span class="p">):</span>
                <span class="n">theta0</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">theta0</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
                <span class="n">SF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
                <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SF</span><span class="o">.</span><span class="n">effectivefishermatrix</span><span class="p">((</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">mp</span><span class="o">.</span><span class="n">TensorField</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">logx</span> <span class="o">=</span> <span class="n">logx</span><span class="p">,</span> <span class="n">logy</span> <span class="o">=</span> <span class="n">logy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iminuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an `iminuit` instance.</span>

<span class="sd">        Model parameters are mapped on `iminuit` variables `x0`, `x1`, `x2`, etc</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta0`:</span>
<span class="sd">            Asimov data</span>
<span class="sd">        * `**kwargs*:</span>
<span class="sd">            Arguments passed on to `iminuit` constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `M` [`iminuit` instance]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">theta0</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>  <span class="c1"># make list</span>
        <span class="n">SF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">chi2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">mu</span><span class="p">()</span>  <span class="c1"># Get proper model prediction</span>
            <span class="n">lnL</span> <span class="o">=</span> <span class="n">SF0</span><span class="o">.</span><span class="n">profile_lnL</span><span class="p">(</span><span class="n">x0</span><span class="o">*</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="n">mu</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">lnL</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">x0err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x0</span><span class="o">&gt;</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x0</span><span class="o">*</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_minuit</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x_err</span> <span class="o">=</span> <span class="n">x0err</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="swordfish.Utils.EquivalentCounts" class="name">class <span class="ident">EquivalentCounts</span></p>
      
  
    <div class="desc"><p><em>Equivalent counts</em> analysis based on a <code>LinModel</code> instance.</p>
<p>The equivalent counts method can be used to derive</p>
<ul>
<li>expected upper limits</li>
<li>discovery reach</li>
<li>equivalent signal and background counts</li>
</ul>
<p>based on the Fisher information matrix of general penalized Poisson
likelihood models.  The results are usually rather accurate, and work in
the statistics limited, background limited and systematics limited regime.
However, they require that the parameter of interest is (a) unconstrained
and (b) corresponds to a component normalization.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.EquivalentCounts', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.EquivalentCounts" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">EquivalentCounts</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;*Equivalent counts* analysis based on a `LinModel` instance.</span>

<span class="sd">    The equivalent counts method can be used to derive</span>
<span class="sd">    </span>
<span class="sd">    - expected upper limits</span>
<span class="sd">    - discovery reach</span>
<span class="sd">    - equivalent signal and background counts</span>
<span class="sd">    </span>
<span class="sd">    based on the Fisher information matrix of general penalized Poisson</span>
<span class="sd">    likelihood models.  The results are usually rather accurate, and work in</span>
<span class="sd">    the statistics limited, background limited and systematics limited regime.</span>
<span class="sd">    However, they require that the parameter of interest is (a) unconstrained</span>
<span class="sd">    and (b) corresponds to a component normalization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Paramters</span>
<span class="sd">        ---------</span>
<span class="sd">        * `model` [instance of `LinModel` class]:</span>
<span class="sd">            Input LinModel model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">totalcounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return total signal and background counts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `theta_i` [float]:</span>
<span class="sd">            Normalization of component i.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `s` [float]:</span>
<span class="sd">            Total signal counts.</span>
<span class="sd">        * `b` [float]:</span>
<span class="sd">            Total background counts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_exposure</span><span class="o">*</span><span class="n">theta_i</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_noise</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">equivalentcounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return equivalent signal and background counts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `theta_i` [float]:</span>
<span class="sd">            Normalization of component i.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `s` [float]:</span>
<span class="sd">            Equivalent signal counts.</span>
<span class="sd">        * `b` [float]:</span>
<span class="sd">            Equivalent background counts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">I0</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">)</span>
        <span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_i</span>
        <span class="n">I</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">thetas</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">I0</span> <span class="o">==</span> <span class="n">I</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">seff</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">I</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">I0</span><span class="p">)</span><span class="o">*</span><span class="n">theta_i</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">beff</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">I0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">I</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">I0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">theta_i</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">seff</span><span class="p">,</span> <span class="n">beff</span>

    <span class="k">def</span> <span class="nf">upperlimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">force_gaussian</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">brentq_kwargs</span>
            <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">}):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return expected upper limit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `alpha` [float]:</span>
<span class="sd">            Statistical significance.  For example, 0.05 means 95% confidence</span>
<span class="sd">            level.</span>
<span class="sd">        * `force_gaussian` [boolean]:</span>
<span class="sd">            Force calculation of Gaussian errors (faster, but only accurate in</span>
<span class="sd">            Gaussian regime).</span>
<span class="sd">        * `brentq_kwargs` [dict]:</span>
<span class="sd">            Keyword arguments passed to root-finding algorithm</span>
<span class="sd">            `scipy.optimize.brentq`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `thetaUL` [float]:</span>
<span class="sd">            Expected median upper limit on $\theta_i$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">I0</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">force_gaussian</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">)</span>
            <span class="n">thetaUL_est</span> <span class="o">=</span> <span class="n">Z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I0</span><span class="p">)</span>  <span class="c1"># Gaussian estimate</span>
            <span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaUL_est</span>
            <span class="n">I</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">thetas</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">I0</span><span class="o">-</span><span class="n">I</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.02</span><span class="o">*</span><span class="n">I</span><span class="p">:</span>  <span class="c1"># 1% accuracy of limits</span>
                <span class="k">return</span> <span class="n">thetaUL_est</span>

        <span class="c1"># Solve: s/np.sqrt(s+b) - Z = 0</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalentcounts</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># TODO: Check</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">Z</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">thetaUL_est</span><span class="o">*</span><span class="n">factor</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">thetaUL_est</span><span class="p">,</span> <span class="n">thetaUL_est</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span> <span class="o">**</span><span class="n">brentq_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">theta0</span>

    <span class="k">def</span> <span class="nf">discoveryreach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">force_gaussian</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
            <span class="n">brentq_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">}):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return expected discovery reach.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `alpha` [float]:</span>
<span class="sd">            Statistical significance.</span>
<span class="sd">        * `force_gaussian` [boolean]:</span>
<span class="sd">            Force calculation of Gaussian errors (faster, but only accurate in</span>
<span class="sd">            Gaussian regime).</span>
<span class="sd">        * `brentq_kwargs` [dict]:</span>
<span class="sd">            Keyword arguments passed to root-finding algorithm</span>
<span class="sd">            `scipy.optimize.brentq`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `thetaDT` [float]:</span>
<span class="sd">            Expected median discovery reach for $\theta_i$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">var0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">force_gaussian</span><span class="p">:</span>  <span class="c1"># Gaussian approximation</span>
            <span class="k">return</span> <span class="n">Z</span><span class="o">*</span><span class="n">var0</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">)</span>
        <span class="n">thetaDT_est</span> <span class="o">=</span> <span class="n">Z</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var0</span><span class="p">)</span>  <span class="c1"># Gaussian approx. as starting point</span>
        <span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaDT_est</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">thetas</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">var0</span> <span class="o">-</span> <span class="n">var</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.02</span><span class="o">*</span><span class="n">var</span><span class="p">:</span>  <span class="c1"># Still Gaussian enough</span>
            <span class="k">return</span> <span class="n">Z</span><span class="o">*</span><span class="n">var0</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="c1"># Solve: Z**2/2 - ((s+b)*np.log((s+b)/b)-s) = 0</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalentcounts</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># TODO: Check</span>
            <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">Z</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">thetaDT_est</span><span class="o">*</span><span class="n">factor</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">thetaDT_est</span><span class="p">,</span> <span class="n">thetaDT_est</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span> <span class="o">**</span><span class="n">brentq_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">theta0</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#swordfish.Utils.EquivalentCounts">EquivalentCounts</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.EquivalentCounts.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, model)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p>
<h2>Paramters</h2>
<ul>
<li><code>model</code> [instance of <code>LinModel</code> class]:
    Input LinModel model.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.EquivalentCounts.__init__', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.EquivalentCounts.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructor.</span>
<span class="sd">    Paramters</span>
<span class="sd">    ---------</span>
<span class="sd">    * `model` [instance of `LinModel` class]:</span>
<span class="sd">        Input LinModel model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.EquivalentCounts.discoveryreach">
    <p>def <span class="ident">discoveryreach</span>(</p><p>self, i, alpha=1e-06, force_gaussian=False, brentq_kwargs={&#39;xtol&#39;: 0.0001})</p>
    </div>
    

    
  
    <div class="desc"><p>Return expected discovery reach.</p>
<h2>Parameters</h2>
<ul>
<li><code>i</code> [integer]:
    Index of component of interest.</li>
<li><code>alpha</code> [float]:
    Statistical significance.</li>
<li><code>force_gaussian</code> [boolean]:
    Force calculation of Gaussian errors (faster, but only accurate in
    Gaussian regime).</li>
<li><code>brentq_kwargs</code> [dict]:
    Keyword arguments passed to root-finding algorithm
    <code>scipy.optimize.brentq</code>.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>thetaDT</code> [float]:
    Expected median discovery reach for $\theta_i$.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.EquivalentCounts.discoveryreach', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.EquivalentCounts.discoveryreach" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">discoveryreach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">force_gaussian</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
        <span class="n">brentq_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">}):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return expected discovery reach.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `i` [integer]:</span>
<span class="sd">        Index of component of interest.</span>
<span class="sd">    * `alpha` [float]:</span>
<span class="sd">        Statistical significance.</span>
<span class="sd">    * `force_gaussian` [boolean]:</span>
<span class="sd">        Force calculation of Gaussian errors (faster, but only accurate in</span>
<span class="sd">        Gaussian regime).</span>
<span class="sd">    * `brentq_kwargs` [dict]:</span>
<span class="sd">        Keyword arguments passed to root-finding algorithm</span>
<span class="sd">        `scipy.optimize.brentq`.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `thetaDT` [float]:</span>
<span class="sd">        Expected median discovery reach for $\theta_i$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">var0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">force_gaussian</span><span class="p">:</span>  <span class="c1"># Gaussian approximation</span>
        <span class="k">return</span> <span class="n">Z</span><span class="o">*</span><span class="n">var0</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">)</span>
    <span class="n">thetaDT_est</span> <span class="o">=</span> <span class="n">Z</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var0</span><span class="p">)</span>  <span class="c1"># Gaussian approx. as starting point</span>
    <span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaDT_est</span>
    <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">thetas</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">var0</span> <span class="o">-</span> <span class="n">var</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.02</span><span class="o">*</span><span class="n">var</span><span class="p">:</span>  <span class="c1"># Still Gaussian enough</span>
        <span class="k">return</span> <span class="n">Z</span><span class="o">*</span><span class="n">var0</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="c1"># Solve: Z**2/2 - ((s+b)*np.log((s+b)/b)-s) = 0</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalentcounts</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># TODO: Check</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">Z</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">thetaDT_est</span><span class="o">*</span><span class="n">factor</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
    <span class="n">theta0</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">thetaDT_est</span><span class="p">,</span> <span class="n">thetaDT_est</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span> <span class="o">**</span><span class="n">brentq_kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">theta0</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.EquivalentCounts.equivalentcounts">
    <p>def <span class="ident">equivalentcounts</span>(</p><p>self, i, theta_i)</p>
    </div>
    

    
  
    <div class="desc"><p>Return equivalent signal and background counts.</p>
<h2>Parameters</h2>
<ul>
<li><code>i</code> [integer]:
    Index of component of interest.</li>
<li><code>theta_i</code> [float]:
    Normalization of component i.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>s</code> [float]:
    Equivalent signal counts.</li>
<li><code>b</code> [float]:
    Equivalent background counts.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.EquivalentCounts.equivalentcounts', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.EquivalentCounts.equivalentcounts" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">equivalentcounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return equivalent signal and background counts.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `i` [integer]:</span>
<span class="sd">        Index of component of interest.</span>
<span class="sd">    * `theta_i` [float]:</span>
<span class="sd">        Normalization of component i.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `s` [float]:</span>
<span class="sd">        Equivalent signal counts.</span>
<span class="sd">    * `b` [float]:</span>
<span class="sd">        Equivalent background counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I0</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">)</span>
    <span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_i</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">thetas</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">I0</span> <span class="o">==</span> <span class="n">I</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">None</span>
    <span class="n">seff</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">I</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">I0</span><span class="p">)</span><span class="o">*</span><span class="n">theta_i</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">beff</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">I0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">I</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">I0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">theta_i</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">seff</span><span class="p">,</span> <span class="n">beff</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.EquivalentCounts.totalcounts">
    <p>def <span class="ident">totalcounts</span>(</p><p>self, i, theta_i)</p>
    </div>
    

    
  
    <div class="desc"><p>Return total signal and background counts.</p>
<h2>Parameters</h2>
<ul>
<li><code>i</code> [integer]:
    Index of component of interest.</li>
<li><code>theta_i</code> [float]:
    Normalization of component i.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>s</code> [float]:
    Total signal counts.</li>
<li><code>b</code> [float]:
    Total background counts.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.EquivalentCounts.totalcounts', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.EquivalentCounts.totalcounts" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">totalcounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta_i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return total signal and background counts.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `i` [integer]:</span>
<span class="sd">        Index of component of interest.</span>
<span class="sd">    * `theta_i` [float]:</span>
<span class="sd">        Normalization of component i.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `s` [float]:</span>
<span class="sd">        Total signal counts.</span>
<span class="sd">    * `b` [float]:</span>
<span class="sd">        Total background counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_exposure</span><span class="o">*</span><span class="n">theta_i</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_noise</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.EquivalentCounts.upperlimit">
    <p>def <span class="ident">upperlimit</span>(</p><p>self, i, alpha=0.05, force_gaussian=False, brentq_kwargs={&#39;xtol&#39;: 0.0001})</p>
    </div>
    

    
  
    <div class="desc"><p>Return expected upper limit.</p>
<h2>Parameters</h2>
<ul>
<li><code>i</code> [integer]:
    Index of component of interest.</li>
<li><code>alpha</code> [float]:
    Statistical significance.  For example, 0.05 means 95% confidence
    level.</li>
<li><code>force_gaussian</code> [boolean]:
    Force calculation of Gaussian errors (faster, but only accurate in
    Gaussian regime).</li>
<li><code>brentq_kwargs</code> [dict]:
    Keyword arguments passed to root-finding algorithm
    <code>scipy.optimize.brentq</code>.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>thetaUL</code> [float]:
    Expected median upper limit on $\theta_i$.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.EquivalentCounts.upperlimit', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.EquivalentCounts.upperlimit" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">upperlimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">force_gaussian</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">brentq_kwargs</span>
        <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">}):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return expected upper limit.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `i` [integer]:</span>
<span class="sd">        Index of component of interest.</span>
<span class="sd">    * `alpha` [float]:</span>
<span class="sd">        Statistical significance.  For example, 0.05 means 95% confidence</span>
<span class="sd">        level.</span>
<span class="sd">    * `force_gaussian` [boolean]:</span>
<span class="sd">        Force calculation of Gaussian errors (faster, but only accurate in</span>
<span class="sd">        Gaussian regime).</span>
<span class="sd">    * `brentq_kwargs` [dict]:</span>
<span class="sd">        Keyword arguments passed to root-finding algorithm</span>
<span class="sd">        `scipy.optimize.brentq`.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `thetaUL` [float]:</span>
<span class="sd">        Expected median upper limit on $\theta_i$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">I0</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">force_gaussian</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">)</span>
        <span class="n">thetaUL_est</span> <span class="o">=</span> <span class="n">Z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I0</span><span class="p">)</span>  <span class="c1"># Gaussian estimate</span>
        <span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaUL_est</span>
        <span class="n">I</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">thetas</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">I0</span><span class="o">-</span><span class="n">I</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.02</span><span class="o">*</span><span class="n">I</span><span class="p">:</span>  <span class="c1"># 1% accuracy of limits</span>
            <span class="k">return</span> <span class="n">thetaUL_est</span>
    <span class="c1"># Solve: s/np.sqrt(s+b) - Z = 0</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalentcounts</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># TODO: Check</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">Z</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">thetaUL_est</span><span class="o">*</span><span class="n">factor</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
    <span class="n">theta0</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">thetaUL_est</span><span class="p">,</span> <span class="n">thetaUL_est</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span> <span class="o">**</span><span class="n">brentq_kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">theta0</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="swordfish.Utils.EuclideanizedSignal" class="name">class <span class="ident">EuclideanizedSignal</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.EuclideanizedSignal', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.EuclideanizedSignal" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">EuclideanizedSignal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># WARNING: This only cares about the covariance matrix and background, not</span>
    <span class="c1"># the individual S components</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;*Effective vector* calculation based on a `LinModel` instance.</span>

<span class="sd">        The distance method provides a simple way to calculate the</span>
<span class="sd">        expected statistical distance between two signals, accounting for</span>
<span class="sd">        background variations and statistical uncertainties.  In practice, it</span>
<span class="sd">        maps signal spectra on distance vectors such that the Eucledian</span>
<span class="sd">        distance between vectors corresponds to the statistical</span>
<span class="sd">        difference between signal spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A0</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_get_A</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return matrix `A`, such that x = A*S is the Eucledian distance vector.&quot;&quot;&quot;</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_noise</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">*</span><span class="mf">1.</span>  <span class="c1"># Noise without anything extra</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">noise</span> <span class="o">+=</span> <span class="n">S</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="n">spexp</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">exposure</span><span class="p">))</span>

        <span class="c1"># Definition: D = N*E + E*Sigma*E</span>
        <span class="n">D</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">noise</span><span class="o">*</span><span class="n">exposure</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">spexp</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_systematics</span><span class="o">*</span><span class="n">spexp</span>
                <span class="p">)</span>
        <span class="c1"># TODO: Add all components and their errors to D</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>  <span class="c1"># transform to dense matrix</span>
        <span class="n">invD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">A2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invD</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">exposure</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">A2</span><span class="p">)</span>
        <span class="n">Kdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_systematics</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">_nbins</span><span class="p">)))</span>
        <span class="n">nA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise</span><span class="o">*</span><span class="n">exposure</span><span class="o">+</span><span class="n">Kdiag</span><span class="o">*</span><span class="n">exposure</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nA</span>

    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return model distance vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `S` [array-like, shape=(n_bins)]:</span>
<span class="sd">            Flux of signal component</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_A</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#swordfish.Utils.EuclideanizedSignal">EuclideanizedSignal</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.EuclideanizedSignal.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, model)</p>
    </div>
    

    
  
    <div class="desc"><p><em>Effective vector</em> calculation based on a <code>LinModel</code> instance.</p>
<p>The distance method provides a simple way to calculate the
expected statistical distance between two signals, accounting for
background variations and statistical uncertainties.  In practice, it
maps signal spectra on distance vectors such that the Eucledian
distance between vectors corresponds to the statistical
difference between signal spectra.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.EuclideanizedSignal.__init__', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.EuclideanizedSignal.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;*Effective vector* calculation based on a `LinModel` instance.</span>
<span class="sd">    The distance method provides a simple way to calculate the</span>
<span class="sd">    expected statistical distance between two signals, accounting for</span>
<span class="sd">    background variations and statistical uncertainties.  In practice, it</span>
<span class="sd">    maps signal spectra on distance vectors such that the Eucledian</span>
<span class="sd">    distance between vectors corresponds to the statistical</span>
<span class="sd">    difference between signal spectra.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_A0</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.EuclideanizedSignal.x">
    <p>def <span class="ident">x</span>(</p><p>self, i, S)</p>
    </div>
    

    
  
    <div class="desc"><p>Return model distance vector.</p>
<h2>Parameters</h2>
<ul>
<li><code>i</code> [integer]:
    Index of component of interest.</li>
<li><code>S</code> [array-like, shape=(n_bins)]:
    Flux of signal component</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.EuclideanizedSignal.x', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.EuclideanizedSignal.x" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return model distance vector.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `i` [integer]:</span>
<span class="sd">        Index of component of interest.</span>
<span class="sd">    * `S` [array-like, shape=(n_bins)]:</span>
<span class="sd">        Flux of signal component</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_A</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="swordfish.Utils.Funkfish" class="name">class <span class="ident">Funkfish</span></p>
      
  
    <div class="desc"><p><code>LinModel</code>, <code>EquivalentCounts</code> and <code>iminuit</code>-factory, based on non-linear models.</p>
<p>The underlying likelihood function is identical to the one of <code>LinModel</code>,
with the only difference that model expectations are derived from
$$
\mu_i(\vec\theta, \delta \vec B) = \left[ f_i(\vec\theta) + \delta B_i\right]\cdot E_i
$$</p>
<p><code>Funkfish</code> can generate <code>LinModel</code> and <code>EquivalentCounts</code> objects as local
approximations to the non-linear model, as well as <code>iminuit</code> instances
based on the non-linear model directly.  This facilitates (a) the fast
analysis of non-linear models and (b) the comparison between results based
on Fisher information and results from a full likelihood analysis.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.Funkfish', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.Funkfish" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Funkfish</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;`LinModel`, `EquivalentCounts` and `iminuit`-factory, based on non-linear models.</span>

<span class="sd">    The underlying likelihood function is identical to the one of `LinModel`,</span>
<span class="sd">    with the only difference that model expectations are derived from</span>
<span class="sd">    $$</span>
<span class="sd">    \mu_i(\vec\theta, \delta \vec B) = \left[ f_i(\vec\theta) + \delta B_i\right]\cdot E_i</span>
<span class="sd">    $$</span>

<span class="sd">    `Funkfish` can generate `LinModel` and `EquivalentCounts` objects as local</span>
<span class="sd">    approximations to the non-linear model, as well as `iminuit` instances</span>
<span class="sd">    based on the non-linear model directly.  This facilitates (a) the fast</span>
<span class="sd">    analysis of non-linear models and (b) the comparison between results based</span>
<span class="sd">    on Fisher information and results from a full likelihood analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `f` [function]:</span>
<span class="sd">            Function of `n_comp` float arguments, returns `n_bins` flux</span>
<span class="sd">            expectation values, $\vec\mu(\vec\theta)$.</span>
<span class="sd">        * `theta0` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Default model parameters.</span>
<span class="sd">        * `E` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Exposure.  See `LinModel` documentation for details.</span>
<span class="sd">        * `K` [matrix-like]:</span>
<span class="sd">            Covariance matrix.  See `LinModel` documentation for details.</span>
<span class="sd">        * `T` [vector-like]:</span>
<span class="sd">            Model parameter constraints.  See `LinModel` documentation for</span>
<span class="sd">            details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Sigma</span> <span class="o">=</span> <span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="n">T</span>

    <span class="k">def</span> <span class="nf">_get_x0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get updated x0.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">x0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">x0</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_init_minuit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">x_fix</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">x_err</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">x_lim</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">errordef</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize minuit using no-nonsense interface.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">iminuit</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s2">&quot;This function requires that the module iminuit is installed.&quot;</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_err</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span>
        <span class="k">if</span> <span class="n">x_lim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_lim</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span>
        <span class="k">if</span> <span class="n">x_fix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_fix</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span>
        <span class="n">varnames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="k">def</span> <span class="nf">wf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">varnames</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x_lim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;limit_&quot;</span><span class="o">+</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_lim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;error_&quot;</span><span class="o">+</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x_fix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;fix_&quot;</span><span class="o">+</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">iminuit</span><span class="o">.</span><span class="n">Minuit</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span> <span class="n">forced_parameters</span> <span class="o">=</span> <span class="n">varnames</span><span class="p">,</span> <span class="n">errordef</span> <span class="o">=</span>
                <span class="n">errordef</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LinModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate `LinModel` instance.</span>

<span class="sd">        The generated `LinModel` instance is a local approximation to the</span>
<span class="sd">        non-linear model.  It is defined by</span>
<span class="sd">        $$</span>
<span class="sd">        B_i \equiv f_i(\vec\theta_0)</span>
<span class="sd">        $$</span>
<span class="sd">        and</span>
<span class="sd">        $$</span>
<span class="sd">        S_i \equiv \frac{\partial f_i}{\partial \theta_i}(\vec\theta_0)</span>
<span class="sd">        $$</span>
<span class="sd">        where $\vec\theta_0$ is the expansion parameter defined below.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta0` [dictionary, or vector-like with shape=(n_comp), or `None`]:</span>
<span class="sd">            If vector-like, it overwrites the default `theta0`.  A dictionary with keys</span>
<span class="sd">            $i$ and values $\theta_i$ updates the default.  If `None` the</span>
<span class="sd">            default is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `SF` [`LinModel` instance]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">_func_to_templates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">(</span><span class="o">*</span><span class="n">x0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LinModel</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Sigma</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EquivalentCounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate `EquivalentCounts` instance.</span>

<span class="sd">        Directly generates `EquivalentCounts` instance from `LinModel`</span>
<span class="sd">        instance.  See documentation of `get_LinModel` method .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EquivalentCounts</span><span class="p">(</span><span class="n">SF</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TensorField</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">logx</span> <span class="o">=</span>
            <span class="bp">False</span><span class="p">,</span> <span class="n">logy</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate `TensorField` instance.</span>

<span class="sd">        Samples Fisher information matrix on a 2-D grid, and generates an</span>
<span class="sd">        instance of `TensorField` that can be used to study parameter</span>
<span class="sd">        degeneracies, confidence contours, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `ix` [integer]:</span>
<span class="sd">            Index of first component of interest, mapped on x-axis.</span>
<span class="sd">        * `iy` [integer]:</span>
<span class="sd">            Index of second component of interest, mapped on y-axis.</span>
<span class="sd">        * `x_values` [vector-like, shape=(nx)]:</span>
<span class="sd">            Values of model parameter `ix` along x-axis.</span>
<span class="sd">        * `y_values` [vector-like, shape=(ny)]:</span>
<span class="sd">            Values of model parameter `iy` along y-axis.</span>
<span class="sd">        * `theta0` [dictionary, or vector-like with shape=(n_comp), or `None`]:</span>
<span class="sd">            If vector-like, it overwrites the default `theta0`.  A dictionary with keys</span>
<span class="sd">            $i$ and values $\theta_i$ updates the default.  If `None` the</span>
<span class="sd">            default is used.  Defines all parameters, except the parameters</span>
<span class="sd">            with indices `ix` and `iy`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `TF` [`TensorField` instance]:</span>
<span class="sd">            Based on an interpolated version of the Fisher information matrix</span>
<span class="sd">            that is sampled from the (nx, ny) grid defined by `x_values` and</span>
<span class="sd">            `y_values`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Update docstring</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_values</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_values</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y_values</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_values</span><span class="p">):</span>
                <span class="n">theta0</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">theta0</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
                <span class="n">SF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
                <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SF</span><span class="o">.</span><span class="n">effectivefishermatrix</span><span class="p">((</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">mp</span><span class="o">.</span><span class="n">TensorField</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">logx</span> <span class="o">=</span> <span class="n">logx</span><span class="p">,</span> <span class="n">logy</span> <span class="o">=</span> <span class="n">logy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iminuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an `iminuit` instance.</span>

<span class="sd">        Model parameters are mapped on `iminuit` variables `x0`, `x1`, `x2`, etc</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta0`:</span>
<span class="sd">            Asimov data</span>
<span class="sd">        * `**kwargs*:</span>
<span class="sd">            Arguments passed on to `iminuit` constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `M` [`iminuit` instance]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">theta0</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>  <span class="c1"># make list</span>
        <span class="n">SF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">chi2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">mu</span><span class="p">()</span>  <span class="c1"># Get proper model prediction</span>
            <span class="n">lnL</span> <span class="o">=</span> <span class="n">SF0</span><span class="o">.</span><span class="n">profile_lnL</span><span class="p">(</span><span class="n">x0</span><span class="o">*</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="n">mu</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">lnL</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">x0err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x0</span><span class="o">&gt;</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x0</span><span class="o">*</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_minuit</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x_err</span> <span class="o">=</span> <span class="n">x0err</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#swordfish.Utils.Funkfish">Funkfish</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.Funkfish.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, f, theta0, E=None, K=None, T=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p>
<h2>Parameters</h2>
<ul>
<li><code>f</code> [function]:
    Function of <code>n_comp</code> float arguments, returns <code>n_bins</code> flux
    expectation values, $\vec\mu(\vec\theta)$.</li>
<li><code>theta0</code> [vector-like, shape=(n_comp)]:
    Default model parameters.</li>
<li><code>E</code> [vector-like, shape=(n_bins)]:
    Exposure.  See <code>LinModel</code> documentation for details.</li>
<li><code>K</code> [matrix-like]:
    Covariance matrix.  See <code>LinModel</code> documentation for details.</li>
<li><code>T</code> [vector-like]:
    Model parameter constraints.  See <code>LinModel</code> documentation for
    details.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.Funkfish.__init__', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.Funkfish.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `f` [function]:</span>
<span class="sd">        Function of `n_comp` float arguments, returns `n_bins` flux</span>
<span class="sd">        expectation values, $\vec\mu(\vec\theta)$.</span>
<span class="sd">    * `theta0` [vector-like, shape=(n_comp)]:</span>
<span class="sd">        Default model parameters.</span>
<span class="sd">    * `E` [vector-like, shape=(n_bins)]:</span>
<span class="sd">        Exposure.  See `LinModel` documentation for details.</span>
<span class="sd">    * `K` [matrix-like]:</span>
<span class="sd">        Covariance matrix.  See `LinModel` documentation for details.</span>
<span class="sd">    * `T` [vector-like]:</span>
<span class="sd">        Model parameter constraints.  See `LinModel` documentation for</span>
<span class="sd">        details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_Sigma</span> <span class="o">=</span> <span class="n">K</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">=</span> <span class="n">E</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="n">T</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.Funkfish.EquivalentCounts">
    <p>def <span class="ident">EquivalentCounts</span>(</p><p>self, theta0=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate <code>EquivalentCounts</code> instance.</p>
<p>Directly generates <code>EquivalentCounts</code> instance from <code>LinModel</code>
instance.  See documentation of <code>get_LinModel</code> method .</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.Funkfish.EquivalentCounts', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.Funkfish.EquivalentCounts" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">EquivalentCounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate `EquivalentCounts` instance.</span>
<span class="sd">    Directly generates `EquivalentCounts` instance from `LinModel`</span>
<span class="sd">    instance.  See documentation of `get_LinModel` method .</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">EquivalentCounts</span><span class="p">(</span><span class="n">SF</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.Funkfish.LinModel">
    <p>def <span class="ident">LinModel</span>(</p><p>self, theta0=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate <code>LinModel</code> instance.</p>
<p>The generated <code>LinModel</code> instance is a local approximation to the
non-linear model.  It is defined by
$$
B_i \equiv f_i(\vec\theta_0)
$$
and
$$
S_i \equiv \frac{\partial f_i}{\partial \theta_i}(\vec\theta_0)
$$
where $\vec\theta_0$ is the expansion parameter defined below.</p>
<h2>Parameters</h2>
<ul>
<li><code>theta0</code> [dictionary, or vector-like with shape=(n_comp), or <code>None</code>]:
    If vector-like, it overwrites the default <code>theta0</code>.  A dictionary with keys
    $i$ and values $\theta_i$ updates the default.  If <code>None</code> the
    default is used.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>SF</code> [<code>LinModel</code> instance]</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.Funkfish.LinModel', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.Funkfish.LinModel" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">LinModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate `LinModel` instance.</span>
<span class="sd">    The generated `LinModel` instance is a local approximation to the</span>
<span class="sd">    non-linear model.  It is defined by</span>
<span class="sd">    $$</span>
<span class="sd">    B_i \equiv f_i(\vec\theta_0)</span>
<span class="sd">    $$</span>
<span class="sd">    and</span>
<span class="sd">    $$</span>
<span class="sd">    S_i \equiv \frac{\partial f_i}{\partial \theta_i}(\vec\theta_0)</span>
<span class="sd">    $$</span>
<span class="sd">    where $\vec\theta_0$ is the expansion parameter defined below.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `theta0` [dictionary, or vector-like with shape=(n_comp), or `None`]:</span>
<span class="sd">        If vector-like, it overwrites the default `theta0`.  A dictionary with keys</span>
<span class="sd">        $i$ and values $\theta_i$ updates the default.  If `None` the</span>
<span class="sd">        default is used.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `SF` [`LinModel` instance]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
    <span class="n">flux</span> <span class="o">=</span> <span class="n">_func_to_templates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">(</span><span class="o">*</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LinModel</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Sigma</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.Funkfish.TensorField">
    <p>def <span class="ident">TensorField</span>(</p><p>self, ix, iy, x_values, y_values, theta0=None, logx=False, logy=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate <code>TensorField</code> instance.</p>
<p>Samples Fisher information matrix on a 2-D grid, and generates an
instance of <code>TensorField</code> that can be used to study parameter
degeneracies, confidence contours, etc.</p>
<h2>Parameters</h2>
<ul>
<li><code>ix</code> [integer]:
    Index of first component of interest, mapped on x-axis.</li>
<li><code>iy</code> [integer]:
    Index of second component of interest, mapped on y-axis.</li>
<li><code>x_values</code> [vector-like, shape=(nx)]:
    Values of model parameter <code>ix</code> along x-axis.</li>
<li><code>y_values</code> [vector-like, shape=(ny)]:
    Values of model parameter <code>iy</code> along y-axis.</li>
<li><code>theta0</code> [dictionary, or vector-like with shape=(n_comp), or <code>None</code>]:
    If vector-like, it overwrites the default <code>theta0</code>.  A dictionary with keys
    $i$ and values $    heta_i$ updates the default.  If <code>None</code> the
    default is used.  Defines all parameters, except the parameters
    with indices <code>ix</code> and <code>iy</code>.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>TF</code> [<code>TensorField</code> instance]:
    Based on an interpolated version of the Fisher information matrix
    that is sampled from the (nx, ny) grid defined by <code>x_values</code> and
    <code>y_values</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.Funkfish.TensorField', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.Funkfish.TensorField" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">TensorField</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">logx</span> <span class="o">=</span>
        <span class="bp">False</span><span class="p">,</span> <span class="n">logy</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate `TensorField` instance.</span>
<span class="sd">    Samples Fisher information matrix on a 2-D grid, and generates an</span>
<span class="sd">    instance of `TensorField` that can be used to study parameter</span>
<span class="sd">    degeneracies, confidence contours, etc.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `ix` [integer]:</span>
<span class="sd">        Index of first component of interest, mapped on x-axis.</span>
<span class="sd">    * `iy` [integer]:</span>
<span class="sd">        Index of second component of interest, mapped on y-axis.</span>
<span class="sd">    * `x_values` [vector-like, shape=(nx)]:</span>
<span class="sd">        Values of model parameter `ix` along x-axis.</span>
<span class="sd">    * `y_values` [vector-like, shape=(ny)]:</span>
<span class="sd">        Values of model parameter `iy` along y-axis.</span>
<span class="sd">    * `theta0` [dictionary, or vector-like with shape=(n_comp), or `None`]:</span>
<span class="sd">        If vector-like, it overwrites the default `theta0`.  A dictionary with keys</span>
<span class="sd">        $i$ and values $\theta_i$ updates the default.  If `None` the</span>
<span class="sd">        default is used.  Defines all parameters, except the parameters</span>
<span class="sd">        with indices `ix` and `iy`.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `TF` [`TensorField` instance]:</span>
<span class="sd">        Based on an interpolated version of the Fisher information matrix</span>
<span class="sd">        that is sampled from the (nx, ny) grid defined by `x_values` and</span>
<span class="sd">        `y_values`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Update docstring</span>
    <span class="n">theta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_values</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_values</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y_values</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_values</span><span class="p">):</span>
            <span class="n">theta0</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">theta0</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">SF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span>
            <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SF</span><span class="o">.</span><span class="n">effectivefishermatrix</span><span class="p">((</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mp</span><span class="o">.</span><span class="n">TensorField</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">logx</span> <span class="o">=</span> <span class="n">logx</span><span class="p">,</span> <span class="n">logy</span> <span class="o">=</span> <span class="n">logy</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.Funkfish.iminuit">
    <p>def <span class="ident">iminuit</span>(</p><p>self, theta0=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return an <code>iminuit</code> instance.</p>
<p>Model parameters are mapped on <code>iminuit</code> variables <code>x0</code>, <code>x1</code>, <code>x2</code>, etc</p>
<h2>Parameters</h2>
<ul>
<li><code>theta0</code>:
    Asimov data</li>
<li><code>**kwargs*:
    Arguments passed on to</code>iminuit` constructor.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>M</code> [<code>iminuit</code> instance]</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.Funkfish.iminuit', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.Funkfish.iminuit" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">iminuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an `iminuit` instance.</span>
<span class="sd">    Model parameters are mapped on `iminuit` variables `x0`, `x1`, `x2`, etc</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `theta0`:</span>
<span class="sd">        Asimov data</span>
<span class="sd">    * `**kwargs*:</span>
<span class="sd">        Arguments passed on to `iminuit` constructor.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `M` [`iminuit` instance]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">theta0</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>  <span class="c1"># make list</span>
    <span class="n">SF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">chi2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LinModel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">mu</span><span class="p">()</span>  <span class="c1"># Get proper model prediction</span>
        <span class="n">lnL</span> <span class="o">=</span> <span class="n">SF0</span><span class="o">.</span><span class="n">profile_lnL</span><span class="p">(</span><span class="n">x0</span><span class="o">*</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="n">mu</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">lnL</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">x0err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x0</span><span class="o">&gt;</span><span class="mf">0.</span><span class="p">,</span> <span class="n">x0</span><span class="o">*</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_minuit</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x_err</span> <span class="o">=</span> <span class="n">x0err</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="swordfish.Utils.LinModel" class="name">class <span class="ident">LinModel</span></p>
      
  
    <div class="desc"><p>Fisher analysis of general penalized Poisson likelihood models.</p>
<p>A model is defined by the following quantities</p>
<ul>
<li>$S_i^{(k)}$: 
    Signal components, with $k=1, \dots, n$ components and $i=1,\dots, N$
    bins.</li>
<li>$B_i$: Background</li>
<li>$E_i$: Exposure</li>
<li>$K_{ij}$: Background covariance matrix</li>
<li>$T_i$: Parameter constraints</li>
</ul>
<p>The corresponding likelihood function is given by
$$
\ln\mathcal{L}(\vec d|\vec\theta) = \max_{\delta B_i} \left[
\ln\mathcal{L}_p(\vec d| \vec\mu(\vec\theta, \delta \vec B)) +
\ln\mathcal{L}_c(\vec\theta, \delta\vec B)
\right]
$$
with a Poisson part
$$
\ln\mathcal{L}_p(\vec d|\vec \mu) = \sum_{i=1}^N d_i \cdot\ln
\mu_i - \mu_i -\ln\Gamma(d_i+1)
$$
and a constraint part
$$
\ln\mathcal{L}_c(\vec\theta, \delta \vec B) = 
\frac12 \sum_i \left(\frac{\theta_i}{T_i}\right)^2
+\frac{1}{2}\sum_{i,j} \delta B_i \left(K^{-1}\right)_{ij} \delta B_j 
\;,
$$
where the expected differential number of counts is given by
$$
\mu_i(\vec\theta,\delta \vec B) = \left[\sum_{k=1}^n \theta_k
S_i^{(k)}+B_i+\delta B_i\right]\cdot E_i \;.
$$</p>
<p>Instances of this class define the model parameters, and provide methods to
calcualte the associated Fisher information matrix and the information
flux.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">LinModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fisher analysis of general penalized Poisson likelihood models.</span>

<span class="sd">    A model is defined by the following quantities</span>

<span class="sd">    * $S_i^{(k)}$: </span>
<span class="sd">        Signal components, with $k=1, \dots, n$ components and $i=1,\dots, N$</span>
<span class="sd">        bins.</span>
<span class="sd">    - $B_i$: Background</span>
<span class="sd">    - $E_i$: Exposure</span>
<span class="sd">    - $K\_{ij}$: Background covariance matrix</span>
<span class="sd">    - $T_i$: Parameter constraints</span>
<span class="sd">    </span>
<span class="sd">    The corresponding likelihood function is given by</span>
<span class="sd">    $$</span>
<span class="sd">    \ln\mathcal{L}(\vec d|\vec\theta) = \max\_{\delta B_i} \left[</span>
<span class="sd">    \ln\mathcal{L}_p(\vec d| \vec\mu(\vec\theta, \delta \vec B)) +</span>
<span class="sd">    \ln\mathcal{L}_c(\vec\theta, \delta\vec B)</span>
<span class="sd">    \right]</span>
<span class="sd">    $$</span>
<span class="sd">    with a Poisson part</span>
<span class="sd">    $$</span>
<span class="sd">    \ln\mathcal{L}_p(\vec d|\vec \mu) = \sum\_{i=1}^N d_i \cdot\ln</span>
<span class="sd">    \mu_i - \mu_i -\ln\Gamma(d_i+1)</span>
<span class="sd">    $$</span>
<span class="sd">    and a constraint part</span>
<span class="sd">    $$</span>
<span class="sd">    \ln\mathcal{L}_c(\vec\theta, \delta \vec B) = </span>
<span class="sd">    \frac12 \sum_i \left(\frac{\theta_i}{T_i}\right)^2</span>
<span class="sd">    +\frac{1}{2}\sum\_{i,j} \delta B_i \left(K^{-1}\right)\_{ij} \delta B_j </span>
<span class="sd">    \;,</span>
<span class="sd">    $$</span>
<span class="sd">    where the expected differential number of counts is given by</span>
<span class="sd">    $$</span>
<span class="sd">    \mu_i(\vec\theta,\delta \vec B) = \left[\sum\_{k=1}^n \theta_k</span>
<span class="sd">    S_i^{(k)}+B_i+\delta B_i\right]\cdot E_i \;.</span>
<span class="sd">    $$</span>

<span class="sd">    Instances of this class define the model parameters, and provide methods to</span>
<span class="sd">    calcualte the associated Fisher information matrix and the information</span>
<span class="sd">    flux.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;direct&#39;</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `S` [matrix-like, shape=(n_comp, n_bins)]:</span>
<span class="sd">            Flux of signal components.</span>
<span class="sd">        * `B` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Background flux.</span>
<span class="sd">        * `E` [vector-like, shape=(n_bins), or `None`]:</span>
<span class="sd">            Exposure.  The value `None` implies that $E_i=1$.</span>
<span class="sd">        * `K` [matrix-like, shape=(n_bins, n_bins), or `None`]:</span>
<span class="sd">            Covariance matrix of background flux uncertainties.  Can handle</span>
<span class="sd">            anything that can be cast to a `LinearOperator` objects, in</span>
<span class="sd">            particular dense and sparse matrices.  The value `None` implies</span>
<span class="sd">            $\delta B_i = 0$.</span>
<span class="sd">        * `T` [vector-like or list-like, shape=(n_comp), or `None`]:</span>
<span class="sd">            Constraints on model parameters.  A list element `None` implies</span>
<span class="sd">            that no constraint is applied to the corresponding parameter.  If</span>
<span class="sd">            `T=None` no constraints are applied to any parameter.</span>
<span class="sd">        * `solver` [`&#39;direct&#39;` or `&#39;cg&#39;`]: </span>
<span class="sd">            Solver method used for matrix inversion, either conjugate gradient</span>
<span class="sd">            (cg) or direct matrix inversion.</span>
<span class="sd">        * `verbose` [boolean]:</span>
<span class="sd">            If set `True` various methods print additional information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;S is not matrix-like.&quot;</span>
        <span class="n">n_comp</span><span class="p">,</span> <span class="n">n_bins</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">=</span> <span class="n">S</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_bins</span><span class="p">,),</span> <span class="s2">&quot;B has incorrect shape.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span> <span class="o">=</span> <span class="n">B</span> 

        <span class="k">if</span> <span class="n">E</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">E</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_bins</span><span class="p">,),</span> <span class="s2">&quot;E has incorrect shape.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">=</span> <span class="n">E</span>

        <span class="k">if</span> <span class="n">K</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">((</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span> 
                    <span class="n">matvec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">assert</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span> <span class="s2">&quot;K has incorrect shape.&quot;</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="k">if</span> <span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_systematics</span> <span class="o">=</span> <span class="n">K</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_constraints</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">n_comp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="n">T</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">=</span> <span class="n">n_bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span> <span class="o">=</span> <span class="n">n_comp</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_auto_scale</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># Initialize internal cache</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_auto_scale</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">exposure</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">exposure</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flux</span><span class="p">]</span>
                <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">constraints</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">==</span> <span class="n">ncomp</span>
        <span class="k">if</span> <span class="n">constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
                    <span class="n">constraints</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">constraints</span><span class="o">&lt;=</span><span class="mf">0.</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Constraints must be positive or None.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">constraints</span>

    <span class="k">def</span> <span class="nf">_summedNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">noise_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span><span class="o">*</span><span class="mf">1.</span>  <span class="c1"># Make copy</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">))):</span>
                <span class="n">noise_tot</span> <span class="o">+=</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">noise_tot</span>

    <span class="k">def</span> <span class="nf">mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return expectation values for given model parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp), or `None`]:</span>
<span class="sd">            Model parameters.  The value `None` implies $\theta_i = 0$.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `mu` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Expectation value, $\mu_i(\vec \theta, \delta \vec B = 0)$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>

    <span class="k">def</span> <span class="nf">_solveD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates:</span>
<span class="sd">            N = noise + theta*flux</span>
<span class="sd">            D = diag(E)*Sigma*diag(E)+diag(N*E)</span>
<span class="sd">            x[i] = D^-1 flux[i]*E</span>

<span class="sd">        Note: if Sigma = None: x[i] = flux[i]/noise</span>

<span class="sd">        Returns:</span>
<span class="sd">            x, noise, exposure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="n">spexp</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">exposure</span><span class="p">))</span>
        <span class="n">D</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">noise</span><span class="o">*</span><span class="n">exposure</span><span class="p">))</span>
                <span class="o">+</span> <span class="n">spexp</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_systematics</span><span class="o">*</span><span class="n">spexp</span>
                <span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">noise</span><span class="o">*</span><span class="n">exposure</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">==</span> <span class="s2">&quot;direct&quot;</span><span class="p">:</span>
            <span class="n">dense</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
            <span class="n">invD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dense</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invD</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">exposure</span><span class="p">)</span><span class="o">*</span><span class="n">exposure</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">==</span> <span class="s2">&quot;cg&quot;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
                    <span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">noise</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">/</span><span class="n">exposure</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cg</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">exposure</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">exposure</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Solver unknown.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">exposure</span>

    <span class="k">def</span> <span class="nf">fishermatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return Fisher information matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters.  The value `None` is equivalent to</span>
<span class="sd">            $\vec\theta=0$.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `I` [matrix-like, shape=(n_comp, n_comp)]:</span>
<span class="sd">            Fisher information matrix, $\mathcal{I}\_{ij}$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solveD</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">I</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">infoflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return Fisher information flux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters.  The value `None` is equivalent to</span>
<span class="sd">            $\vec\theta=0$.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `F` [3-D array, shape=(n_comp, n_comp, n_bins)]:</span>
<span class="sd">            Fisher information flux.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solveD</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">noise</span><span class="o">/</span><span class="p">(</span><span class="n">exposure</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span>
                <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="n">F</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">F</span>

    <span class="k">def</span> <span class="nf">effectivefishermatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexlist</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return effective Fisher information matrix for subset of components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `indexlist` [integer, or list of integers]:</span>
<span class="sd">            Components of interest.</span>
<span class="sd">        * `**kwargs`:</span>
<span class="sd">            Passed on to call of `fishermatrix`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `Ieff` [float, or matrix-like, shape=(len(indexlist),</span>
<span class="sd">            len(indexlist))]:</span>
<span class="sd">            Effective Fisher information matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexlist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
            <span class="n">indexlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexlist</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">),</span> <span class="n">indexlist</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexlist</span><span class="p">)</span>

        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fishermatrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indexlist</span><span class="p">,:][:,</span><span class="n">indexlist</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">,:][:,</span><span class="n">indexlist</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">,:][:,</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">invC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

        <span class="n">Ieff</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invC</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Ieff</span>

    <span class="k">def</span> <span class="nf">variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return variance of $\theta_i$.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]: </span>
<span class="sd">            Index of component of interest</span>
<span class="sd">        * `**kwargs`:</span>
<span class="sd">            Passed on to call of `fishermatrix`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `var` [float]:</span>
<span class="sd">            Variance of parameter $\theta_i$.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fishermatrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">invI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">invI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">effectiveinfoflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return effective Fisher Information Flux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `i` [integer]:</span>
<span class="sd">            Index of component of interest.</span>
<span class="sd">        * `**kwargs`:</span>
<span class="sd">            Passed on to call of `fishermatrix` and `infoflux`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `Feff` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Effective information flux.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infoflux</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fishermatrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">eff_F</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
        <span class="n">invB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">eff_F</span> <span class="o">=</span> <span class="n">eff_F</span> <span class="o">-</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">eff_F</span> <span class="o">=</span> <span class="n">eff_F</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">F</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">eff_F</span> <span class="o">=</span> <span class="n">eff_F</span> <span class="o">+</span> <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">F</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">eff_F</span>

    <span class="c1"># Likelihood with systematics</span>
    <span class="k">def</span> <span class="nf">lnL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">deltaB</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">derivative</span> <span class="o">=</span>
            <span class="bp">False</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return log-likelihood function, assuming Asimov data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        * `theta0` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters used for calculation of Asimov data.  Note that</span>
<span class="sd">            Asimov data is generated assuming $\delta\vec B =0$.</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters.</span>
<span class="sd">        * `deltaB`: [vector-like, shape=(n_bins)]:</span>
<span class="sd">            Background variations of model.  A value of `None` corresponds to</span>
<span class="sd">            $\delta\vec B = 0$.</span>
<span class="sd">        * `epsilon` [float]:</span>
<span class="sd">            Fraction of diagonal noise that is added to K to stabilize matrix</span>
<span class="sd">            inversion.  Must be small enough to not affect results.</span>
<span class="sd">        * `derivative` [boolean]:</span>
<span class="sd">            If set to `True`, function also resturns partial derivatives w.r.t.</span>
<span class="sd">            model parameters.</span>
<span class="sd">        * `mu_overwrite` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            This parameter is internally used to handle non-linear models.  It</span>
<span class="sd">            overwrites the model predictions that are derived from `theta` and</span>
<span class="sd">            `deltaB`.  In that case, `theta` and `deltaB` only affect the</span>
<span class="sd">            constraint part of the likelihood.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `lnL` [float]:</span>
<span class="sd">            Log-likelihood, including Poisson and constraint part.</span>

<span class="sd">        OR if `derivative == True`</span>

<span class="sd">        * `lnL, dlnL_dtheta, dlnL_deltaB` </span>
<span class="sd">            [(float, vector-like with shape=(n_comp), vector-like with shape=(n_bins))]:</span>
<span class="sd">            Log-likelihood and its partial derivatives.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">deltaB</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="n">systnoise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span><span class="o">*</span><span class="n">epsilon</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="k">if</span> <span class="n">mu_overwrite</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">mu_overwrite</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dmu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">+=</span> <span class="n">dmu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_at_bound</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">mu</span><span class="o">&lt;</span><span class="n">mu0</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mu</span><span class="o">&lt;</span><span class="n">mu0</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">mu0</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
        <span class="n">lnL</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">-</span><span class="n">mu</span><span class="o">-</span><span class="mi">0</span><span class="o">*</span><span class="n">gammaln</span><span class="p">(</span><span class="n">mu0</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1">#print mu0.sum(), mu.sum()</span>
        <span class="n">lnL</span> <span class="o">-=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">theta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
            <span class="n">dense</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_systematics</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
            <span class="c1">#invS = np.linalg.linalg.inv(dense+np.eye(self._nbins)*epsilon)</span>
            <span class="n">invS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dense</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">systnoise</span><span class="p">))</span>
            <span class="n">lnL</span> <span class="o">-=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">invS</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmu</span><span class="p">)</span><span class="o">*</span><span class="n">dmu</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">derivative</span><span class="p">:</span>
            <span class="n">dlnL_dtheta</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu0</span><span class="o">/</span><span class="n">mu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">dlnL_dtheta</span> <span class="o">-=</span> <span class="n">theta</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
                <span class="n">dlnL_dmu</span> <span class="o">=</span> <span class="n">mu0</span><span class="o">/</span><span class="n">mu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">-</span> <span class="n">invS</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmu</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dlnL_dmu</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">lnL</span><span class="p">,</span> <span class="n">dlnL_dtheta</span><span class="p">,</span> <span class="n">dlnL_dmu</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lnL</span>

    <span class="k">def</span> <span class="nf">profile_lnL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">free_theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
            <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return profile log-likelihood.</span>

<span class="sd">        Note: Profiling is done using `scipy.optimize.fmin_l_bfgs_b`.  All</span>
<span class="sd">        $\delta \vec B$ are treated as free parameters, as well as those model</span>
<span class="sd">        parameters $\theta_i$ that are specified in `free_theta`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        * `theta0` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters used for calculation of Asimov data.  Note that</span>
<span class="sd">            Asimov data is generated assuming $\delta\vec B =0$.</span>
<span class="sd">        * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">            Model parameters.</span>
<span class="sd">        * `epsilon` [float]:</span>
<span class="sd">            Fraction of diagonal noise that is added to K to stabilize matrix</span>
<span class="sd">            inversion.  Must be small enough to not affect results.</span>
<span class="sd">        * `free_theta` [list-like, shape=(n_comp)]:</span>
<span class="sd">            If a list entry is set to `True`, the corresponding model parameter</span>
<span class="sd">            will be maximized.</span>
<span class="sd">        * `mu_overwrite` [vector-like, shape=(n_bins)]:</span>
<span class="sd">            See `lnL`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        * `profile_lnL` [float]:</span>
<span class="sd">            Profile log-likelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">free_theta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">free_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">free_theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">Nfree_theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_theta</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">Nsyst</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">Nfree_theta</span> <span class="o">+</span> <span class="n">Nsyst</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">x0</span><span class="p">[:</span><span class="n">Nfree_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">free_theta</span><span class="p">]</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">global</span> <span class="n">fp</span>
            <span class="n">theta</span><span class="p">[</span><span class="n">free_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">Nfree_theta</span><span class="p">]</span>
            <span class="n">dmu</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">Nfree_theta</span><span class="p">:]</span>
            <span class="n">lnL</span><span class="p">,</span> <span class="n">grad_theta</span><span class="p">,</span> <span class="n">grad_dmu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnL</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">deltaB</span> <span class="o">=</span> <span class="n">dmu</span><span class="p">,</span>
                    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">derivative</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="n">mu_overwrite</span><span class="p">)</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="n">fp</span><span class="p">[:</span><span class="n">Nfree_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_theta</span><span class="p">[</span><span class="n">free_theta</span><span class="p">]</span>
            <span class="n">fp</span><span class="p">[</span><span class="n">Nfree_theta</span><span class="p">:]</span> <span class="o">=</span> <span class="n">grad_dmu</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">lnL</span>
        <span class="k">def</span> <span class="nf">fprime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">global</span> <span class="n">fp</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">fp</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnL</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="n">mu_overwrite</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fmin_l_bfgs_b</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">fprime</span><span class="p">,</span> <span class="n">approx_grad</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s2">&quot;Best-fit parameters:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_bound</span><span class="p">:</span>
            <span class="k">print</span> <span class="s2">&quot;WARNING: No maximum with non-negative flux found.&quot;</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#swordfish.Utils.LinModel">LinModel</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.LinModel.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, S, B, E=None, K=None, T=None, solver=&#39;direct&#39;, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructor.</p>
<h2>Parameters</h2>
<ul>
<li><code>S</code> [matrix-like, shape=(n_comp, n_bins)]:
    Flux of signal components.</li>
<li><code>B</code> [vector-like, shape=(n_bins)]:
    Background flux.</li>
<li><code>E</code> [vector-like, shape=(n_bins), or <code>None</code>]:
    Exposure.  The value <code>None</code> implies that $E_i=1$.</li>
<li><code>K</code> [matrix-like, shape=(n_bins, n_bins), or <code>None</code>]:
    Covariance matrix of background flux uncertainties.  Can handle
    anything that can be cast to a <code>LinearOperator</code> objects, in
    particular dense and sparse matrices.  The value <code>None</code> implies
    $\delta B_i = 0$.</li>
<li><code>T</code> [vector-like or list-like, shape=(n_comp), or <code>None</code>]:
    Constraints on model parameters.  A list element <code>None</code> implies
    that no constraint is applied to the corresponding parameter.  If
    <code>T=None</code> no constraints are applied to any parameter.</li>
<li><code>solver</code> [<code>'direct'</code> or <code>'cg'</code>]: 
    Solver method used for matrix inversion, either conjugate gradient
    (cg) or direct matrix inversion.</li>
<li><code>verbose</code> [boolean]:
    If set <code>True</code> various methods print additional information.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel.__init__', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;direct&#39;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `S` [matrix-like, shape=(n_comp, n_bins)]:</span>
<span class="sd">        Flux of signal components.</span>
<span class="sd">    * `B` [vector-like, shape=(n_bins)]:</span>
<span class="sd">        Background flux.</span>
<span class="sd">    * `E` [vector-like, shape=(n_bins), or `None`]:</span>
<span class="sd">        Exposure.  The value `None` implies that $E_i=1$.</span>
<span class="sd">    * `K` [matrix-like, shape=(n_bins, n_bins), or `None`]:</span>
<span class="sd">        Covariance matrix of background flux uncertainties.  Can handle</span>
<span class="sd">        anything that can be cast to a `LinearOperator` objects, in</span>
<span class="sd">        particular dense and sparse matrices.  The value `None` implies</span>
<span class="sd">        $\delta B_i = 0$.</span>
<span class="sd">    * `T` [vector-like or list-like, shape=(n_comp), or `None`]:</span>
<span class="sd">        Constraints on model parameters.  A list element `None` implies</span>
<span class="sd">        that no constraint is applied to the corresponding parameter.  If</span>
<span class="sd">        `T=None` no constraints are applied to any parameter.</span>
<span class="sd">    * `solver` [`&#39;direct&#39;` or `&#39;cg&#39;`]: </span>
<span class="sd">        Solver method used for matrix inversion, either conjugate gradient</span>
<span class="sd">        (cg) or direct matrix inversion.</span>
<span class="sd">    * `verbose` [boolean]:</span>
<span class="sd">        If set `True` various methods print additional information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;S is not matrix-like.&quot;</span>
    <span class="n">n_comp</span><span class="p">,</span> <span class="n">n_bins</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_flux</span> <span class="o">=</span> <span class="n">S</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_bins</span><span class="p">,),</span> <span class="s2">&quot;B has incorrect shape.&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span> <span class="o">=</span> <span class="n">B</span> 
    <span class="k">if</span> <span class="n">E</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">E</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_bins</span><span class="p">,),</span> <span class="s2">&quot;E has incorrect shape.&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">=</span> <span class="n">E</span>
    <span class="k">if</span> <span class="n">K</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">((</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span> 
                <span class="n">matvec</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">assert</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span> <span class="s2">&quot;K has incorrect shape.&quot;</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">aslinearoperator</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="k">if</span> <span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_systematics</span> <span class="o">=</span> <span class="n">K</span>
    <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_constraints</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">n_comp</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="n">T</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span> <span class="o">=</span> <span class="n">n_bins</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span> <span class="o">=</span> <span class="n">n_comp</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">=</span> <span class="n">solver</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_auto_scale</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># Initialize internal cache</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.LinModel.effectivefishermatrix">
    <p>def <span class="ident">effectivefishermatrix</span>(</p><p>self, indexlist, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return effective Fisher information matrix for subset of components.</p>
<h2>Parameters</h2>
<ul>
<li><code>indexlist</code> [integer, or list of integers]:
    Components of interest.</li>
<li><code>**kwargs</code>:
    Passed on to call of <code>fishermatrix</code>.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>Ieff</code> [float, or matrix-like, shape=(len(indexlist),
    len(indexlist))]:
    Effective Fisher information matrix.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel.effectivefishermatrix', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel.effectivefishermatrix" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">effectivefishermatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexlist</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return effective Fisher information matrix for subset of components.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `indexlist` [integer, or list of integers]:</span>
<span class="sd">        Components of interest.</span>
<span class="sd">    * `**kwargs`:</span>
<span class="sd">        Passed on to call of `fishermatrix`.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `Ieff` [float, or matrix-like, shape=(len(indexlist),</span>
<span class="sd">        len(indexlist))]:</span>
<span class="sd">        Effective Fisher information matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexlist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
        <span class="n">indexlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexlist</span><span class="p">]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">),</span> <span class="n">indexlist</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexlist</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fishermatrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indexlist</span><span class="p">,:][:,</span><span class="n">indexlist</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">,:][:,</span><span class="n">indexlist</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">,:][:,</span><span class="n">indices</span><span class="p">]</span>
    <span class="n">invC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">Ieff</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invC</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Ieff</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.LinModel.effectiveinfoflux">
    <p>def <span class="ident">effectiveinfoflux</span>(</p><p>self, i, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return effective Fisher Information Flux.</p>
<h2>Parameters</h2>
<ul>
<li><code>i</code> [integer]:
    Index of component of interest.</li>
<li><code>**kwargs</code>:
    Passed on to call of <code>fishermatrix</code> and <code>infoflux</code>.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>Feff</code> [vector-like, shape=(n_bins)]:
    Effective information flux.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel.effectiveinfoflux', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel.effectiveinfoflux" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">effectiveinfoflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return effective Fisher Information Flux.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `i` [integer]:</span>
<span class="sd">        Index of component of interest.</span>
<span class="sd">    * `**kwargs`:</span>
<span class="sd">        Passed on to call of `fishermatrix` and `infoflux`.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `Feff` [vector-like, shape=(n_bins)]:</span>
<span class="sd">        Effective information flux.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infoflux</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fishermatrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">eff_F</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
    <span class="n">invB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">eff_F</span> <span class="o">=</span> <span class="n">eff_F</span> <span class="o">-</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">eff_F</span> <span class="o">=</span> <span class="n">eff_F</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">F</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">eff_F</span> <span class="o">=</span> <span class="n">eff_F</span> <span class="o">+</span> <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">*</span><span class="n">F</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span><span class="o">*</span><span class="n">invB</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">eff_F</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.LinModel.fishermatrix">
    <p>def <span class="ident">fishermatrix</span>(</p><p>self, theta=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return Fisher information matrix.</p>
<h2>Parameters</h2>
<ul>
<li><code>theta</code> [vector-like, shape=(n_comp)]:
    Model parameters.  The value <code>None</code> is equivalent to
    $\vec\theta=0$.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>I</code> [matrix-like, shape=(n_comp, n_comp)]:
    Fisher information matrix, $\mathcal{I}_{ij}$.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel.fishermatrix', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel.fishermatrix" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">fishermatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return Fisher information matrix.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">        Model parameters.  The value `None` is equivalent to</span>
<span class="sd">        $\vec\theta=0$.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `I` [matrix-like, shape=(n_comp, n_comp)]:</span>
<span class="sd">        Fisher information matrix, $\mathcal{I}\_{ij}$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solveD</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.LinModel.infoflux">
    <p>def <span class="ident">infoflux</span>(</p><p>self, theta=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return Fisher information flux.</p>
<h2>Parameters</h2>
<ul>
<li><code>theta</code> [vector-like, shape=(n_comp)]:
    Model parameters.  The value <code>None</code> is equivalent to
    $\vec\theta=0$.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>F</code> [3-D array, shape=(n_comp, n_comp, n_bins)]:
    Fisher information flux.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel.infoflux', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel.infoflux" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">infoflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return Fisher information flux.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">        Model parameters.  The value `None` is equivalent to</span>
<span class="sd">        $\vec\theta=0$.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `F` [3-D array, shape=(n_comp, n_comp, n_bins)]:</span>
<span class="sd">        Fisher information flux.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solveD</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ncomp</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">noise</span><span class="o">/</span><span class="p">(</span><span class="n">exposure</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span>
            <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">F</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="k">return</span> <span class="n">F</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.LinModel.lnL">
    <p>def <span class="ident">lnL</span>(</p><p>self, theta0, theta, deltaB=None, epsilon=0.001, derivative=False, mu_overwrite=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return log-likelihood function, assuming Asimov data.</p>
<h2>Parameters</h2>
<ul>
<li><code>theta0</code> [vector-like, shape=(n_comp)]:
    Model parameters used for calculation of Asimov data.  Note that
    Asimov data is generated assuming $\delta\vec B =0$.</li>
<li><code>theta</code> [vector-like, shape=(n_comp)]:
    Model parameters.</li>
<li><code>deltaB</code>: [vector-like, shape=(n_bins)]:
    Background variations of model.  A value of <code>None</code> corresponds to
    $\delta\vec B = 0$.</li>
<li><code>epsilon</code> [float]:
    Fraction of diagonal noise that is added to K to stabilize matrix
    inversion.  Must be small enough to not affect results.</li>
<li><code>derivative</code> [boolean]:
    If set to <code>True</code>, function also resturns partial derivatives w.r.t.
    model parameters.</li>
<li><code>mu_overwrite</code> [vector-like, shape=(n_bins)]:
    This parameter is internally used to handle non-linear models.  It
    overwrites the model predictions that are derived from <code>theta</code> and
    <code>deltaB</code>.  In that case, <code>theta</code> and <code>deltaB</code> only affect the
    constraint part of the likelihood.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>lnL</code> [float]:
    Log-likelihood, including Poisson and constraint part.</li>
</ul>
<p>OR if <code>derivative == True</code></p>
<ul>
<li><code>lnL, dlnL_dtheta, dlnL_deltaB</code> 
    [(float, vector-like with shape=(n_comp), vector-like with shape=(n_bins))]:
    Log-likelihood and its partial derivatives.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel.lnL', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel.lnL" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">lnL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">deltaB</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">derivative</span> <span class="o">=</span>
        <span class="bp">False</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return log-likelihood function, assuming Asimov data.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `theta0` [vector-like, shape=(n_comp)]:</span>
<span class="sd">        Model parameters used for calculation of Asimov data.  Note that</span>
<span class="sd">        Asimov data is generated assuming $\delta\vec B =0$.</span>
<span class="sd">    * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">        Model parameters.</span>
<span class="sd">    * `deltaB`: [vector-like, shape=(n_bins)]:</span>
<span class="sd">        Background variations of model.  A value of `None` corresponds to</span>
<span class="sd">        $\delta\vec B = 0$.</span>
<span class="sd">    * `epsilon` [float]:</span>
<span class="sd">        Fraction of diagonal noise that is added to K to stabilize matrix</span>
<span class="sd">        inversion.  Must be small enough to not affect results.</span>
<span class="sd">    * `derivative` [boolean]:</span>
<span class="sd">        If set to `True`, function also resturns partial derivatives w.r.t.</span>
<span class="sd">        model parameters.</span>
<span class="sd">    * `mu_overwrite` [vector-like, shape=(n_bins)]:</span>
<span class="sd">        This parameter is internally used to handle non-linear models.  It</span>
<span class="sd">        overwrites the model predictions that are derived from `theta` and</span>
<span class="sd">        `deltaB`.  In that case, `theta` and `deltaB` only affect the</span>
<span class="sd">        constraint part of the likelihood.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `lnL` [float]:</span>
<span class="sd">        Log-likelihood, including Poisson and constraint part.</span>
<span class="sd">    OR if `derivative == True`</span>
<span class="sd">    * `lnL, dlnL_dtheta, dlnL_deltaB` </span>
<span class="sd">        [(float, vector-like with shape=(n_comp), vector-like with shape=(n_bins))]:</span>
<span class="sd">        Log-likelihood and its partial derivatives.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dmu</span> <span class="o">=</span> <span class="n">deltaB</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">theta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">mu0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
    <span class="n">systnoise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta0</span><span class="p">)</span><span class="o">*</span><span class="n">epsilon</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
    <span class="k">if</span> <span class="n">mu_overwrite</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">mu_overwrite</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dmu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">+=</span> <span class="n">dmu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_at_bound</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">mu</span><span class="o">&lt;</span><span class="n">mu0</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mu</span><span class="o">&lt;</span><span class="n">mu0</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">mu0</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">lnL</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">-</span><span class="n">mu</span><span class="o">-</span><span class="mi">0</span><span class="o">*</span><span class="n">gammaln</span><span class="p">(</span><span class="n">mu0</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1">#print mu0.sum(), mu.sum()</span>
    <span class="n">lnL</span> <span class="o">-=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">theta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
        <span class="n">dense</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_systematics</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbins</span><span class="p">))</span>
        <span class="c1">#invS = np.linalg.linalg.inv(dense+np.eye(self._nbins)*epsilon)</span>
        <span class="n">invS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dense</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">systnoise</span><span class="p">))</span>
        <span class="n">lnL</span> <span class="o">-=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">invS</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmu</span><span class="p">)</span><span class="o">*</span><span class="n">dmu</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">derivative</span><span class="p">:</span>
        <span class="n">dlnL_dtheta</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu0</span><span class="o">/</span><span class="n">mu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_flux</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dlnL_dtheta</span> <span class="o">-=</span> <span class="n">theta</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span><span class="p">:</span>
            <span class="n">dlnL_dmu</span> <span class="o">=</span> <span class="n">mu0</span><span class="o">/</span><span class="n">mu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">-</span> <span class="n">invS</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dlnL_dmu</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">lnL</span><span class="p">,</span> <span class="n">dlnL_dtheta</span><span class="p">,</span> <span class="n">dlnL_dmu</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lnL</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.LinModel.mu">
    <p>def <span class="ident">mu</span>(</p><p>self, theta=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return expectation values for given model parameters.</p>
<h2>Parameters</h2>
<ul>
<li><code>theta</code> [vector-like, shape=(n_comp), or <code>None</code>]:
    Model parameters.  The value <code>None</code> implies $\theta_i = 0$.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>mu</code> [vector-like, shape=(n_bins)]:
    Expectation value, $\mu_i(\vec \theta, \delta \vec B = 0)$.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel.mu', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel.mu" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return expectation values for given model parameters.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `theta` [vector-like, shape=(n_comp), or `None`]:</span>
<span class="sd">        Model parameters.  The value `None` implies $\theta_i = 0$.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `mu` [vector-like, shape=(n_bins)]:</span>
<span class="sd">        Expectation value, $\mu_i(\vec \theta, \delta \vec B = 0)$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summedNoise</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.LinModel.profile_lnL">
    <p>def <span class="ident">profile_lnL</span>(</p><p>self, theta0, theta, epsilon=0.001, free_theta=None, mu_overwrite=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return profile log-likelihood.</p>
<p>Note: Profiling is done using <code>scipy.optimize.fmin_l_bfgs_b</code>.  All
$\delta \vec B$ are treated as free parameters, as well as those model
parameters $\theta_i$ that are specified in <code>free_theta</code>.</p>
<h2>Parameters</h2>
<ul>
<li><code>theta0</code> [vector-like, shape=(n_comp)]:
    Model parameters used for calculation of Asimov data.  Note that
    Asimov data is generated assuming $\delta\vec B =0$.</li>
<li><code>theta</code> [vector-like, shape=(n_comp)]:
    Model parameters.</li>
<li><code>epsilon</code> [float]:
    Fraction of diagonal noise that is added to K to stabilize matrix
    inversion.  Must be small enough to not affect results.</li>
<li><code>free_theta</code> [list-like, shape=(n_comp)]:
    If a list entry is set to <code>True</code>, the corresponding model parameter
    will be maximized.</li>
<li><code>mu_overwrite</code> [vector-like, shape=(n_bins)]:
    See <code>lnL</code>.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>profile_lnL</code> [float]:
    Profile log-likelihood.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel.profile_lnL', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel.profile_lnL" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">profile_lnL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">free_theta</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return profile log-likelihood.</span>
<span class="sd">    Note: Profiling is done using `scipy.optimize.fmin_l_bfgs_b`.  All</span>
<span class="sd">    $\delta \vec B$ are treated as free parameters, as well as those model</span>
<span class="sd">    parameters $\theta_i$ that are specified in `free_theta`.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    * `theta0` [vector-like, shape=(n_comp)]:</span>
<span class="sd">        Model parameters used for calculation of Asimov data.  Note that</span>
<span class="sd">        Asimov data is generated assuming $\delta\vec B =0$.</span>
<span class="sd">    * `theta` [vector-like, shape=(n_comp)]:</span>
<span class="sd">        Model parameters.</span>
<span class="sd">    * `epsilon` [float]:</span>
<span class="sd">        Fraction of diagonal noise that is added to K to stabilize matrix</span>
<span class="sd">        inversion.  Must be small enough to not affect results.</span>
<span class="sd">    * `free_theta` [list-like, shape=(n_comp)]:</span>
<span class="sd">        If a list entry is set to `True`, the corresponding model parameter</span>
<span class="sd">        will be maximized.</span>
<span class="sd">    * `mu_overwrite` [vector-like, shape=(n_bins)]:</span>
<span class="sd">        See `lnL`.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `profile_lnL` [float]:</span>
<span class="sd">        Profile log-likelihood.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="n">theta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">free_theta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">free_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">free_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">free_theta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">Nfree_theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_theta</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Nsyst</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sysflag</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">Nfree_theta</span> <span class="o">+</span> <span class="n">Nsyst</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">x0</span><span class="p">[:</span><span class="n">Nfree_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">free_theta</span><span class="p">]</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">fp</span>
        <span class="n">theta</span><span class="p">[</span><span class="n">free_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">Nfree_theta</span><span class="p">]</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">Nfree_theta</span><span class="p">:]</span>
        <span class="n">lnL</span><span class="p">,</span> <span class="n">grad_theta</span><span class="p">,</span> <span class="n">grad_dmu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnL</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">deltaB</span> <span class="o">=</span> <span class="n">dmu</span><span class="p">,</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">derivative</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="n">mu_overwrite</span><span class="p">)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">fp</span><span class="p">[:</span><span class="n">Nfree_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_theta</span><span class="p">[</span><span class="n">free_theta</span><span class="p">]</span>
        <span class="n">fp</span><span class="p">[</span><span class="n">Nfree_theta</span><span class="p">:]</span> <span class="o">=</span> <span class="n">grad_dmu</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">lnL</span>
    <span class="k">def</span> <span class="nf">fprime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">fp</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">fp</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnL</span><span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">mu_overwrite</span> <span class="o">=</span> <span class="n">mu_overwrite</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">fmin_l_bfgs_b</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">fprime</span><span class="p">,</span> <span class="n">approx_grad</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s2">&quot;Best-fit parameters:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at_bound</span><span class="p">:</span>
        <span class="k">print</span> <span class="s2">&quot;WARNING: No maximum with non-negative flux found.&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="swordfish.Utils.LinModel.variance">
    <p>def <span class="ident">variance</span>(</p><p>self, i, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return variance of $\theta_i$.</p>
<h2>Parameters</h2>
<ul>
<li><code>i</code> [integer]: 
    Index of component of interest</li>
<li><code>**kwargs</code>:
    Passed on to call of <code>fishermatrix</code>.</li>
</ul>
<h2>Returns</h2>
<ul>
<li><code>var</code> [float]:
    Variance of parameter $\theta_i$.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-swordfish.Utils.LinModel.variance', this);">Show source &equiv;</a></p>
  <div id="source-swordfish.Utils.LinModel.variance" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return variance of $\theta_i$.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    * `i` [integer]: </span>
<span class="sd">        Index of component of interest</span>
<span class="sd">    * `**kwargs`:</span>
<span class="sd">        Passed on to call of `fishermatrix`.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    * `var` [float]:</span>
<span class="sd">        Variance of parameter $\theta_i$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fishermatrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">invI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">invI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
